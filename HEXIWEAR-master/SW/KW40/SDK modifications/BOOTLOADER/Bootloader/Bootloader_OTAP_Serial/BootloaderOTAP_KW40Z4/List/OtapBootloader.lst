###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        12/Jan/2016  08:59:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\OtapSerialBootloader\OtapBootloader.c
#    Command line =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\OtapSerialBootloader\OtapBootloader.c
#        -D MCU_MKW40Z160 -D gEepromType_d=gEepromDevice_M25P80_c
#        --preprocess=cl
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\
#        -lC
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\
#        -lA
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\
#        --diag_suppress Pa039 -o
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\OtapSerialBootloader\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\spi\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\eeprom\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\flash\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\include\cfg\
#        -On --c89
#    List file    =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\OtapBootloader.lst
#    Object file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\Obj\OtapBootloader.o
#
###############################################################################

C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\OtapSerialBootloader\OtapBootloader.c
      1          /*!
      2          * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * \file OtapBootloader.c
      6          *
      7          * Redistribution and use in source and binary forms, with or without modification,
      8          * are permitted provided that the following conditions are met:
      9          *
     10          * o Redistributions of source code must retain the above copyright notice, this list
     11          *   of conditions and the following disclaimer.
     12          *
     13          * o Redistributions in binary form must reproduce the above copyright notice, this
     14          *   list of conditions and the following disclaimer in the documentation and/or
     15          *   other materials provided with the distribution.
     16          *
     17          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     18          *   contributors may be used to endorse or promote products derived from this
     19          *   software without specific prior written permission.
     20          *
     21          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     22          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     23          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     24          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     25          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     26          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     27          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     28          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     29          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     30          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31          */
     32          
     33          
     34          /*! *********************************************************************************
     35          *************************************************************************************
     36          * Include
     37          *************************************************************************************
     38          ********************************************************************************** */
     39          #include "OtapBootloader.h"
     40          #include "flash_boot_kinetis.h"
     41          #include "Eeprom_Boot.h"
     42          #include "UartBootloader.h"
     43          
     44          
     45          /*! *********************************************************************************
     46          *************************************************************************************
     47          * Private Memory Declarations
     48          *************************************************************************************
     49          ********************************************************************************** */
     50          #if defined(__IAR_SYSTEMS_ICC__)
     51          #pragma section = "IntVectTable"
     52          #pragma location = "IntVectTable"

   \                                 In section IntVectTable, align 4, root
     53          __root const vector_entry __vector_table[16] =
   \                     __vector_table:
   \   00000000   0x........         DC32 __BOOT_STACK_ADDRESS, __thumb_startup, defaultISR, defaultISR
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x........         DC32 defaultISR, defaultISR, defaultISR, defaultISR, defaultISR
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000024   0x........         DC32 defaultISR, defaultISR, defaultISR, defaultISR, defaultISR
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000038   0x........         DC32 defaultISR, defaultISR
   \              0x........   
     54          {
     55              (pointer*)__BOOT_STACK_ADDRESS,  /* Initial SP           */
     56          
     57          #elif defined(__GNUC__)
     58          const vector_entry __vector_table[16] __attribute__ ((section(".vectortable"))) =
     59          {
     60              (pointer*)__SP_INIT,  /* Initial SP           */
     61          #endif
     62          
     63              __thumb_startup, /* Initial PC           */
     64              defaultISR,      /* Non-maskable Interrupt (NMI) */
     65              defaultISR,      /* Hard Fault */
     66              defaultISR,      /* MemManage Fault */
     67              defaultISR,      /* Bus Fault */
     68              defaultISR,      /* Usage Fault */
     69              defaultISR,      /* Usage Fault */
     70              defaultISR,      /* Usage Fault */
     71              defaultISR,      /* Usage Fault */
     72              defaultISR,      /* Usage Fault */
     73              defaultISR,      /* Usage Fault */
     74              defaultISR,      /* Usage Fault */
     75              defaultISR,      /* Usage Fault */
     76              defaultISR,      /* Usage Fault */
     77              defaultISR       /* Usage Fault */
     78          };
     79          
     80          #if defined(__IAR_SYSTEMS_ICC__)
     81          #pragma location = "FlashConfig"

   \                                 In section FlashConfig, align 4, root
     82          __root const FlashConfig_t gFlashConfig @ "FlashConfig" =
   \                     gFlashConfig:
   \   00000000   0xFFFFFFFF         DC32 4294967295, 4294967295, 4294967295, 4294967294
   \              0xFFFFFFFF   
   \              0xFFFFFFFF   
   \              0xFFFFFFFE   
     83          #elif defined(__GNUC__)
     84          const FlashConfig_t gFlashConfig __attribute__ ((section(".cfmconfig"))) =
     85          #endif
     86          {
     87              {0xFFFFFFFF, 0xFFFFFFFF, gFlashProtection_c, 0xFFFFFFFE}
     88          };
     89          
     90          /* Variables used by the Bootloader */

   \                                 In section .bss, align 4
     91          volatile bootInfo_t *gpBootInfo;
   \                     gpBootInfo:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     92          volatile uint32_t gBootStorageStartAddress;
   \                     gBootStorageStartAddress:
   \   00000000                      DS8 4
     93          
     94          
     95          /*! *********************************************************************************
     96          *************************************************************************************
     97          * Public Functions
     98          *************************************************************************************
     99          ********************************************************************************** */
    100          
    101          /*! *********************************************************************************
    102          * \brief   This function determines the start address of the internal sorage.
    103          *          If value is 0xFFFFFFFF then external storage should be used!
    104          *
    105          * \return the start address of the internal storage
    106          *
    107          ********************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    108          uint32_t Boot_GetInternalStorageStartAddr(void)
    109          {
    110              return *((uint32_t*)(gBootProductInfoAddress_c + gInternalStorageStartAddressOffset_c));
   \                     Boot_GetInternalStorageStartAddr: (+1)
   \   00000000   0x....             LDR      R0,??DataTable5  ;; 0x27c44
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    111          }
    112          
    113          
    114          /*! *********************************************************************************
    115          * \brief   The function resets the MCU
    116          *
    117          ********************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    118          void Boot_ResetMCU(void)
    119          {
   \                     Boot_ResetMCU: (+1)
   \   00000000   0xB500             PUSH     {LR}
    120              SCB_AIRCR = SCB_AIRCR_VECTKEY(0x5FA) | SCB_AIRCR_SYSRESETREQ_MASK;
   \   00000002   0x....             LDR      R0,??DataTable5_1  ;; 0x5fa0004
   \   00000004   0x....             LDR      R1,??DataTable5_2  ;; 0xe000ed0c
   \   00000006   0x6008             STR      R0,[R1, #+0]
    121              while(1);
   \                     ??Boot_ResetMCU_0: (+1)
   \   00000008   0xE7FE             B        ??Boot_ResetMCU_0
    122          }
    123          
    124          
    125          /*! *********************************************************************************
    126          * \brief   Start the user application
    127          *
    128          * \param[in] userStartup  Address of the application's interrupt vector
    129          *
    130          ********************************************************************************** */

   \                                 In section .text, align 4, keep-with-next
    131          static void JumpToApplication(volatile uint32_t userStartup)
    132          {
   \                     JumpToApplication: (+1)
   \   00000000   0xB401             PUSH     {R0}
    133              /* Enable ALL interrupts */
    134              asm("     cpsie   i       ");
   \   00000002   0xB662             cpsie   i       
    135          
    136              /* set up stack pointer */
    137              asm("LDR      r1,  [r0]");
   \   00000004   0x6801             LDR      r1,  [r0]
    138              asm("MSR      MSP, r1");
   \   00000006   0xF381 0x8808      MSR      MSP, r1
    139          
    140              /* jump to application reset vector */
    141              asm("ADDS     r0,r0,#0x04 ");
   \   0000000A   0x1D00             ADDS     r0,r0,#0x04 
    142              asm("LDR      r0, [r0]");
   \   0000000C   0x6800             LDR      r0, [r0]
    143              asm("BX       r0");
   \   0000000E   0x4700             BX       r0
    144          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0x4770             BX       LR               ;; return
    145          
    146          
    147          /*! *********************************************************************************
    148          * \brief   Initialize the external storage
    149          *
    150          * \return status
    151          *
    152          ********************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    153          uint8_t Boot_InitExternalStorage(void)
    154          {
   \                     Boot_InitExternalStorage: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    155              if (gBootInvalidAddress_c == gBootStorageStartAddress)
   \   00000002   0x....             LDR      R0,??DataTable5_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD102             BNE      ??Boot_InitExternalStorage_0
    156                  return EEPROM_Init();
   \   0000000E   0x.... 0x....      BL       EEPROM_Init
   \   00000012   0xE000             B        ??Boot_InitExternalStorage_1
    157          
    158              return 0;
   \                     ??Boot_InitExternalStorage_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??Boot_InitExternalStorage_1: (+1)
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    159          }
    160          
    161          
    162          /*! *********************************************************************************
    163          * \brief   Read data from the external stoage
    164          *
    165          * \param[in]  NoOfBytes  number of byter to read
    166          * \param[in]  Addr       read memory address
    167          * \param[out] outbuf     location where read data is stored
    168          *
    169          * \return error code. 0 if success
    170          *
    171          ********************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    172          uint8_t Boot_ReadExternalStorage(uint16_t NoOfBytes, uint32_t Addr, uint8_t *outbuf)
    173          {
   \                     Boot_ReadExternalStorage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    174              if (gBootInvalidAddress_c == gBootStorageStartAddress)
   \   00000008   0x....             LDR      R0,??DataTable5_3
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD106             BNE      ??Boot_ReadExternalStorage_0
    175              {
    176                  return EEPROM_ReadData(NoOfBytes, Addr, outbuf);
   \   00000014   0x0032             MOVS     R2,R6
   \   00000016   0x0029             MOVS     R1,R5
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB280             UXTH     R0,R0
   \   0000001C   0x.... 0x....      BL       EEPROM_ReadData
   \   00000020   0xE00D             B        ??Boot_ReadExternalStorage_1
    177              }
    178              else
    179              {
    180                  Addr += gBootStorageStartAddress;
   \                     ??Boot_ReadExternalStorage_0: (+1)
   \   00000022   0x....             LDR      R0,??DataTable5_3
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x182D             ADDS     R5,R5,R0
    181                  while(NoOfBytes--)
   \                     ??Boot_ReadExternalStorage_2: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x1E44             SUBS     R4,R0,#+1
   \   0000002C   0xB280             UXTH     R0,R0
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD004             BEQ      ??Boot_ReadExternalStorage_3
    182                  {
    183                      *outbuf++ = *((uint8_t*)Addr++);
   \   00000032   0x7828             LDRB     R0,[R5, #+0]
   \   00000034   0x7030             STRB     R0,[R6, #+0]
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   \   00000038   0x1C76             ADDS     R6,R6,#+1
   \   0000003A   0xE7F5             B        ??Boot_ReadExternalStorage_2
    184                  }
    185          
    186                  return 0;
   \                     ??Boot_ReadExternalStorage_3: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??Boot_ReadExternalStorage_1: (+1)
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    187              }
    188          }
    189          
    190          
    191          /*! *********************************************************************************
    192          * \brief   This function will copy the User Application from the external memory
    193          *          into the program Flash
    194          *
    195          ********************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    196          void Boot_LoadImage (void)
    197          {
   \                     Boot_LoadImage: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x....             LDR      R4,??DataTable5_4  ;; 0xfffffbec
   \   00000004   0x44A5             ADD      SP,SP,R4
    198              static uint8_t bitmapBuffer[gBootData_SectorsBitmap_Size_c];
    199              bootInfo_t flags;
    200              uint8_t  buffer[gFlashErasePage_c];
    201              uint32_t remaingImgSize, len;
    202              uint32_t flashAddr      = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    203              uint8_t  bitMask        = gBitMaskInit_c;
   \   00000008   0x2701             MOVS     R7,#+1
    204              uint8_t *pBitmap        = bitmapBuffer;
   \   0000000A   0x....             LDR      R0,??DataTable5_5
   \   0000000C   0x9003             STR      R0,[SP, #+12]
    205          #if defined(MCU_MK21DX256)
    206              vuint8_t* pFlexRamAddress;
    207              uint8_t  EEEDataSetSize;
    208              uint16_t size;
    209          #endif
    210          
    211              /* Check if we have a valid internal storage start address. */
    212              gBootStorageStartAddress = Boot_GetInternalStorageStartAddr();
   \   0000000E   0x.... 0x....      BL       Boot_GetInternalStorageStartAddr
   \   00000012   0x....             LDR      R1,??DataTable5_3
   \   00000014   0x6008             STR      R0,[R1, #+0]
    213          
    214              /* Init the flash module */
    215              FlashInitialization();
   \   00000016   0x.... 0x....      BL       FlashInitialization
    216          
    217              /* Init the external storage */
    218              Boot_InitExternalStorage();
   \   0000001A   0x.... 0x....      BL       Boot_InitExternalStorage
    219          
    220              /* Read image size */
    221              if (Boot_ReadExternalStorage(gBootData_ImageLength_Size_c,gBootData_ImageLength_Offset_c, (uint8_t*)(&remaingImgSize)))
   \   0000001E   0xAA01             ADD      R2,SP,#+4
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0x.... 0x....      BL       Boot_ReadExternalStorage
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ      ??Boot_LoadImage_0
    222                  gHandleBootError_d();
   \   0000002C   0x.... 0x....      BL       Boot_ResetMCU
    223          
    224              /* Read sector bitmap */
    225              if (Boot_ReadExternalStorage(gBootData_SectorsBitmap_Size_c, gBootData_SectorsBitmap_Offset_c, bitmapBuffer))
   \                     ??Boot_LoadImage_0: (+1)
   \   00000030   0x....             LDR      R2,??DataTable5_5
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0x.... 0x....      BL       Boot_ReadExternalStorage
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD001             BEQ      ??Boot_LoadImage_1
    226                  gHandleBootError_d();
   \   0000003E   0x.... 0x....      BL       Boot_ResetMCU
    227          
    228              /* Start writing the image. Do not alter the last sector which contains HW specific data! */
    229              while (flashAddr < (gMcuFlashSize_c - gFlashErasePage_c))
   \                     ??Boot_LoadImage_1: (+1)
   \   00000042   0x209F             MOVS     R0,#+159
   \   00000044   0x0280             LSLS     R0,R0,#+10       ;; #+162816
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xD27B             BCS      ??Boot_LoadImage_2
    230              {
    231                  if (remaingImgSize > gFlashErasePage_c)
   \   0000004A   0x9801             LDR      R0,[SP, #+4]
   \   0000004C   0x....             LDR      R1,??DataTable5_6  ;; 0x401
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD303             BCC      ??Boot_LoadImage_3
    232                      len = gFlashErasePage_c;
   \   00000052   0x2080             MOVS     R0,#+128
   \   00000054   0x00C0             LSLS     R0,R0,#+3        ;; #+1024
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0xE001             B        ??Boot_LoadImage_4
    233                  else
    234                      len = remaingImgSize;
   \                     ??Boot_LoadImage_3: (+1)
   \   0000005A   0x9801             LDR      R0,[SP, #+4]
   \   0000005C   0x9000             STR      R0,[SP, #+0]
    235          
    236                  /* Check if bitmap indicates that this sector is write protected and shouldn't be updated */
    237                  if ((*pBitmap & bitMask) && (flashAddr >= gUserFlashStart_d))
   \                     ??Boot_LoadImage_4: (+1)
   \   0000005E   0x9803             LDR      R0,[SP, #+12]
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x4238             TST      R0,R7
   \   00000064   0xD059             BEQ      ??Boot_LoadImage_5
   \   00000066   0x....             LDR      R0,??DataTable5_7
   \   00000068   0x4285             CMP      R5,R0
   \   0000006A   0xD356             BCC      ??Boot_LoadImage_5
    238                  {
    239                      /* Erase Flash sector */
    240                      if (FLASH_OK != FLASH_EraseSector(flashAddr))
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0x.... 0x....      BL       FLASH_EraseSector
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD001             BEQ      ??Boot_LoadImage_6
    241                          gHandleBootError_d();
   \   00000076   0x.... 0x....      BL       Boot_ResetMCU
    242          
    243                      if (len)
   \                     ??Boot_LoadImage_6: (+1)
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD04C             BEQ      ??Boot_LoadImage_5
    244                      {
    245                          /* Read a new image block */
    246                          if (Boot_ReadExternalStorage(len, flashAddr + gBootData_Image_Offset_c, buffer))
   \   00000080   0xAA04             ADD      R2,SP,#+16
   \   00000082   0x0029             MOVS     R1,R5
   \   00000084   0x3124             ADDS     R1,R1,#+36
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0xB280             UXTH     R0,R0
   \   0000008A   0x.... 0x....      BL       Boot_ReadExternalStorage
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD001             BEQ      ??Boot_LoadImage_7
    247                              gHandleBootError_d();
   \   00000092   0x.... 0x....      BL       Boot_ResetMCU
    248          
    249          
    250                          if( (flashAddr <= gBootImageFlagsAddress_c) && (flashAddr + len > gBootImageFlagsAddress_c) )
   \                     ??Boot_LoadImage_7: (+1)
   \   00000096   0x....             LDR      R0,??DataTable5_8
   \   00000098   0x42A8             CMP      R0,R5
   \   0000009A   0xD335             BCC      ??Boot_LoadImage_8
   \   0000009C   0x....             LDR      R0,??DataTable5_8
   \   0000009E   0x9900             LDR      R1,[SP, #+0]
   \   000000A0   0x1869             ADDS     R1,R5,R1
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD230             BCS      ??Boot_LoadImage_8
    251                          {
    252                              uint32_t i, offset = gBootImageFlagsAddress_c - flashAddr;
   \   000000A6   0x....             LDR      R0,??DataTable5_8
   \   000000A8   0x1B46             SUBS     R6,R0,R5
    253                              /* Program the Flash before boot flags */
    254                              if(FLASH_OK != FLASH_Program(flashAddr, (uint32_t)buffer, offset))
   \   000000AA   0x0032             MOVS     R2,R6
   \   000000AC   0xA904             ADD      R1,SP,#+16
   \   000000AE   0x0028             MOVS     R0,R5
   \   000000B0   0x.... 0x....      BL       FLASH_Program
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD001             BEQ      ??Boot_LoadImage_9
    255                                  gHandleBootError_d();
   \   000000B8   0x.... 0x....      BL       Boot_ResetMCU
    256          
    257                              /* Keep the boot flags set  until the all image is downloaded */
    258                              for( i=0; i<gEepromParams_WriteAlignment_c; i++ )
   \                     ??Boot_LoadImage_9: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x0004             MOVS     R4,R0
   \                     ??Boot_LoadImage_10: (+1)
   \   000000C0   0x2C00             CMP      R4,#+0
   \   000000C2   0xD108             BNE      ??Boot_LoadImage_11
    259                              {
    260                                  flags.newBootImageAvailable[i] = gBootValueForFALSE_c;
   \   000000C4   0x20FF             MOVS     R0,#+255
   \   000000C6   0xA902             ADD      R1,SP,#+8
   \   000000C8   0x5508             STRB     R0,[R1, R4]
    261                                  flags.bootProcessCompleted[i] = gBootValueForTRUE_c;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xA902             ADD      R1,SP,#+8
   \   000000CE   0x1909             ADDS     R1,R1,R4
   \   000000D0   0x7048             STRB     R0,[R1, #+1]
    262                              }
   \   000000D2   0x1C64             ADDS     R4,R4,#+1
   \   000000D4   0xE7F4             B        ??Boot_LoadImage_10
    263                              i = offset + 2 * gEepromParams_WriteAlignment_c;
   \                     ??Boot_LoadImage_11: (+1)
   \   000000D6   0x0030             MOVS     R0,R6
   \   000000D8   0x1C80             ADDS     R0,R0,#+2
   \   000000DA   0x0004             MOVS     R4,R0
    264                              flags.bootVersion[0] = buffer[i++];
   \   000000DC   0xA804             ADD      R0,SP,#+16
   \   000000DE   0x5D00             LDRB     R0,[R0, R4]
   \   000000E0   0xA902             ADD      R1,SP,#+8
   \   000000E2   0x7088             STRB     R0,[R1, #+2]
   \   000000E4   0x1C64             ADDS     R4,R4,#+1
    265                              flags.bootVersion[1] = buffer[i];
   \   000000E6   0xA804             ADD      R0,SP,#+16
   \   000000E8   0x5D00             LDRB     R0,[R0, R4]
   \   000000EA   0xA902             ADD      R1,SP,#+8
   \   000000EC   0x70C8             STRB     R0,[R1, #+3]
    266                              offset += gEepromAlignAddr_d(sizeof(bootInfo_t));
   \   000000EE   0x1D36             ADDS     R6,R6,#+4
    267          
    268                              /* Program the Flash after the boot flags*/
    269                              if(FLASH_OK != FLASH_Program(flashAddr + offset, (uint32_t)(&buffer[offset]), len - offset))
   \   000000F0   0x9800             LDR      R0,[SP, #+0]
   \   000000F2   0x1B82             SUBS     R2,R0,R6
   \   000000F4   0xA804             ADD      R0,SP,#+16
   \   000000F6   0x1981             ADDS     R1,R0,R6
   \   000000F8   0x19A8             ADDS     R0,R5,R6
   \   000000FA   0x.... 0x....      BL       FLASH_Program
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD00B             BEQ      ??Boot_LoadImage_5
    270                                  gHandleBootError_d();
   \   00000102   0x.... 0x....      BL       Boot_ResetMCU
   \   00000106   0xE008             B        ??Boot_LoadImage_5
    271                          }
    272                          else
    273                          {
    274                              /* Program the image block to Flash */
    275                              if(FLASH_OK != FLASH_Program(flashAddr, (uint32_t)buffer, len))
   \                     ??Boot_LoadImage_8: (+1)
   \   00000108   0x9A00             LDR      R2,[SP, #+0]
   \   0000010A   0xA904             ADD      R1,SP,#+16
   \   0000010C   0x0028             MOVS     R0,R5
   \   0000010E   0x.... 0x....      BL       FLASH_Program
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD001             BEQ      ??Boot_LoadImage_5
    276                                  gHandleBootError_d();
   \   00000116   0x.... 0x....      BL       Boot_ResetMCU
    277                          }
    278                      }
    279                  }
    280          
    281                  /* Update Bitmask */
    282                  bitMask <<= 1;
   \                     ??Boot_LoadImage_5: (+1)
   \   0000011A   0x007F             LSLS     R7,R7,#+1
    283                  if (bitMask == 0)
   \   0000011C   0xB2FF             UXTB     R7,R7
   \   0000011E   0x2F00             CMP      R7,#+0
   \   00000120   0xD104             BNE      ??Boot_LoadImage_12
    284                  {
    285                      /* This was last bit in the current bitmap byte. Move to next bitmap byte */
    286                      bitMask = gBitMaskInit_c;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0x0007             MOVS     R7,R0
    287                      pBitmap++;
   \   00000126   0x9803             LDR      R0,[SP, #+12]
   \   00000128   0x1C40             ADDS     R0,R0,#+1
   \   0000012A   0x9003             STR      R0,[SP, #+12]
    288                  }
    289          
    290                  /* Update the current flash address */
    291                  flashAddr += gFlashErasePage_c;
   \                     ??Boot_LoadImage_12: (+1)
   \   0000012C   0x2080             MOVS     R0,#+128
   \   0000012E   0x00C0             LSLS     R0,R0,#+3        ;; #+1024
   \   00000130   0x182D             ADDS     R5,R5,R0
    292          
    293                  /* Update the remaining bytes*/
    294                  if (remaingImgSize)
   \   00000132   0x9801             LDR      R0,[SP, #+4]
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD084             BEQ      ??Boot_LoadImage_1
    295                      remaingImgSize -= len;
   \   00000138   0x9801             LDR      R0,[SP, #+4]
   \   0000013A   0x9900             LDR      R1,[SP, #+0]
   \   0000013C   0x1A40             SUBS     R0,R0,R1
   \   0000013E   0x9001             STR      R0,[SP, #+4]
   \   00000140   0xE77F             B        ??Boot_LoadImage_1
    296              } /* while */
    297          
    298          #if defined(MCU_MK21DX256)
    299          
    300              while((FTFL_FSTAT & FTFL_FSTAT_CCIF_MASK) != FTFL_FSTAT_CCIF_MASK)
    301              {
    302                  /* wait till CCIF bit is set */
    303              }
    304          
    305              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
    306              FTFL_FSTAT = (FTFL_FSTAT_RDCOLERR_MASK | FTFL_FSTAT_ACCERR_MASK |
    307                            FTFL_FSTAT_FPVIOL_MASK);
    308          
    309              /* Write Command Code to FCCOB0 */
    310              FTFL_FCCOB0 = FLASH_READ_RESOURCE;
    311              /* Write address to FCCOB1/2/3 */
    312              FTFL_FCCOB1 = ((uint8_t)(FLASH_DFLASH_IFR_READRESOURCE_ADDRESS >> 16));
    313              FTFL_FCCOB2 = ((uint8_t)((FLASH_DFLASH_IFR_READRESOURCE_ADDRESS >> 8) & 0xFF));
    314              FTFL_FCCOB3 = ((uint8_t)(FLASH_DFLASH_IFR_READRESOURCE_ADDRESS & 0xFF));
    315          
    316              /* Write Resource Select Code of 0 to FCCOB8 to select IFR. Without this, */
    317              /* an access error may occur if the register contains data from a previous command. */
    318              FTFL_FCCOB8 = 0;
    319          
    320              /* clear CCIF bit */
    321              FTFL_FSTAT |= FTFL_FSTAT_CCIF_MASK;
    322          
    323              /* check CCIF bit */
    324              while((FTFL_FSTAT & FTFL_FSTAT_CCIF_MASK) != FTFL_FSTAT_CCIF_MASK)
    325              {
    326                  /* wait till CCIF bit is set */
    327              }
    328          
    329              /* read the FlexRAM window size */
    330              EEEDataSetSize = FTFL_FCCOB6;
    331              EEEDataSetSize &= 0x0F;
    332          
    333              if((EEEDataSetSize == 2) || (EEEDataSetSize == 3)) /* FlexRAM size is 4KB or 2KB */
    334              {
    335                  /* Enable EEE */
    336                  FLASH_SetEEEEnable(FLASH_FLEXRAM_FNC_CTRL_CODE);
    337          
    338                  pBitmap = &bitmapBuffer[0] + (uint32_t)((gMcuFlashSize_c/gFlashErasePage_c)/8);
    339          
    340                  if(EEEDataSetSize == 2) /* 4KB */
    341                  {
    342                      if(*pBitmap & 0x01)
    343                      {
    344                          size = gBootFlexRam_4K_Size_c/2;
    345                          pFlexRamAddress = (vuint8_t*)((uint32_t)gBootFlexRAMBaseAddress_c);
    346                          while(size--)
    347                          {
    348                              /* wait for EEPROM system to be ready */
    349                              while(!(FTFL_FCNFG & FTFL_FCNFG_EEERDY_MASK));
    350                              *pFlexRamAddress = 0xFF;
    351                              pFlexRamAddress ++;
    352                          }
    353                      }
    354                      if(*pBitmap & 0x02)
    355                      {
    356                          size = gBootFlexRam_4K_Size_c/2;
    357                          pFlexRamAddress = (vuint8_t*)((uint32_t)(gBootFlexRAMBaseAddress_c + size));
    358                          while(size--)
    359                          {
    360                              /* wait for EEPROM system to be ready */
    361                              while(!(FTFL_FCNFG & FTFL_FCNFG_EEERDY_MASK));
    362                              *pFlexRamAddress = 0xFF;
    363                              pFlexRamAddress ++;
    364                          }
    365                      }
    366                  }
    367                  else if (EEEDataSetSize == 3) /* 2K */
    368                  {
    369                      if(*pBitmap & 0x01)
    370                      {
    371                          size = gBootFlexRam_2K_Size_c/2;
    372                          pFlexRamAddress = (vuint8_t*)((uint32_t)gBootFlexRAMBaseAddress_c);
    373                          while(size--)
    374                          {
    375                              /* wait for EEPROM system to be ready */
    376                              while(!(FTFL_FCNFG & FTFL_FCNFG_EEERDY_MASK));
    377                              *pFlexRamAddress = 0xFF;
    378                              pFlexRamAddress ++;
    379                          }
    380                      }
    381                      if(*pBitmap & 0x02)
    382                      {
    383                          size = gBootFlexRam_2K_Size_c/2;
    384                          pFlexRamAddress = (vuint8_t*)((uint32_t)(gBootFlexRAMBaseAddress_c + size));
    385                          while(size--)
    386                          {
    387                              /* wait for EEPROM system to be ready */
    388                              while(!(FTFL_FCNFG & FTFL_FCNFG_EEERDY_MASK));
    389                              *pFlexRamAddress = 0xFF;
    390                              pFlexRamAddress ++;
    391                          }
    392                      }
    393                  }
    394              }
    395          #endif
    396          
    397          
    398              /* Set the bBootProcessCompleted Flag */
    399              if( FLASH_OK != FLASH_Program((uint32_t)gBootImageFlagsAddress_c, (uint32_t)&flags, sizeof(flags)) )
   \                     ??Boot_LoadImage_2: (+1)
   \   00000142   0x2204             MOVS     R2,#+4
   \   00000144   0xA902             ADD      R1,SP,#+8
   \   00000146   0x....             LDR      R0,??DataTable5_8
   \   00000148   0x.... 0x....      BL       FLASH_Program
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xD001             BEQ      ??Boot_LoadImage_13
    400                  gHandleBootError_d();
   \   00000150   0x.... 0x....      BL       Boot_ResetMCU
    401          
    402              /* Reseting MCU */
    403              Boot_ResetMCU();
   \                     ??Boot_LoadImage_13: (+1)
   \   00000154   0x.... 0x....      BL       Boot_ResetMCU
    404          }
   \   00000158   0x....             LDR      R0,??DataTable5_9  ;; 0x414
   \   0000015A   0x4485             ADD      SP,SP,R0
   \   0000015C   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??bitmapBuffer:
   \   00000000                      DS8 32
    405          
    406          /*! *********************************************************************************
    407          * \brief   This is the Bootloader's entry point
    408          *
    409          ********************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    410          void __thumb_startup(void)
    411          {
   \                     __thumb_startup: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    412              (void)main(0, 0);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       main
    413          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    414          
    415          /*! *********************************************************************************
    416          * \brief   This is the main Bootloader function.
    417          *          It decides if it will load a new image or jump to the application
    418          *
    419          * \param[in] argc
    420          * \param[in] argv
    421          *
    422          * \return int
    423          *
    424          ********************************************************************************** */

   \                                 In section .text, align 4, keep-with-next
    425          int main(int argc, char **argv)
    426          {
   \                     main: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    427              /* Disable interrupt by default */
    428              asm("     CPSID   i       ");
   \   00000006   0xB672             CPSID   i       
    429          
    430              /* Set the start address of the interrupt vector*/
    431              SCB_VTOR = (uint32_t)__region_BOOT_ROM_start__;
   \   00000008   0x....             LDR      R0,??DataTable5_10
   \   0000000A   0x....             LDR      R1,??DataTable5_11  ;; 0xe000ed08
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    432          
    433              /* Disable watchdog */
    434          #if defined(MCU_MK21DN512) || defined(MCU_MK21DX256) || defined(MCU_MK64FN1M)
    435              WDOG_UNLOCK = 0xC520;
    436              WDOG_UNLOCK = 0xD928;
    437              WDOG_STCTRLH &= ~WDOG_STCTRLH_WDOGEN_MASK;
    438          #elif defined(MCU_MKL46Z256) || defined(MCU_MKW40Z160)
    439              SIM_COPC = SIM_COPC_COPT(0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR      R1,??DataTable5_12  ;; 0x40048100
   \   00000012   0x6008             STR      R0,[R1, #+0]
    440          #endif
    441          #if gSerialBootloaderEnable_c
    442              BOOT_PIN_ENABLE_SIM_SCG_REG |= BOOT_PIN_ENABLE_SIM_SCG_MASK;
    443              PORT_PCR_REG(BOOT_PIN_ENABLE_PORT_BASE,BOOT_PIN_ENABLE_NUM) = PORT_PCR_MUX(1) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK;
    444              {
    445                  vuint32_t delay;
    446                  delay = 5;
    447                  while(--delay);
    448              }
    449              if((GPIO_PDIR_REG(BOOT_PIN_ENABLE_GPIO_BASE) & (1 << BOOT_PIN_ENABLE_NUM)) == 0)
    450              {
    451                  CheckForUartLoader();
    452              }
    453          #endif
    454              /* Check if there is no boot image available in the external EEPROM and if eventually
    455              the booting of the previous one has been completed. If both conditions are met, start
    456              running the application in the internal Flash. Else, start the process of booting from
    457              external EEPROM */
    458              gpBootInfo = (bootInfo_t*)gBootImageFlagsAddress_c;
   \   00000014   0x....             LDR      R0,??DataTable5_8
   \   00000016   0x....             LDR      R1,??DataTable5_13
   \   00000018   0x6008             STR      R0,[R1, #+0]
    459              /*
    460              if( (gpBootInfo->newBootImageAvailable == gBootValueForTRUE_c) &&
    461              (gpBootInfo->bootProcessCompleted ==  gBootValueForFALSE_c) )
    462              */
    463              if ((gpBootInfo->newBootImageAvailable[0] != gBootValueForTRUE_c) &&
    464                  (gpBootInfo->bootProcessCompleted[0] ==  gBootValueForTRUE_c))
   \   0000001A   0x....             LDR      R0,??DataTable5_13
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD00B             BEQ      ??main_0
   \   00000024   0x....             LDR      R0,??DataTable5_13
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x7840             LDRB     R0,[R0, #+1]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD106             BNE      ??main_0
    465              {
    466                  /* Set the start address of the interrupt vector*/
    467                  SCB_VTOR = gUserFlashStart_d;
   \   0000002E   0x....             LDR      R0,??DataTable5_7
   \   00000030   0x....             LDR      R1,??DataTable5_11  ;; 0xe000ed08
   \   00000032   0x6008             STR      R0,[R1, #+0]
    468                  JumpToApplication(gUserFlashStart_d);
   \   00000034   0x....             LDR      R0,??DataTable5_7
   \   00000036   0x.... 0x....      BL       JumpToApplication
   \   0000003A   0xE001             B        ??main_1
    469              }
    470              else
    471              {
    472                  /* Write the new image */
    473                  Boot_LoadImage();
   \                     ??main_0: (+1)
   \   0000003C   0x.... 0x....      BL       Boot_LoadImage
    474              }
    475          
    476              return 0;
   \                     ??main_1: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    477          }
    478          
    479          /*! *********************************************************************************
    480          * \brief   Default ISR handler
    481          *
    482          ********************************************************************************** */

   \                                 In section .text, align 2, keep-with-next
    483          void defaultISR(void)
    484          {
   \                     defaultISR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    485              /* ISR code */
    486              gHandleBootError_d();
   \   00000002   0x.... 0x....      BL       Boot_ResetMCU
    487          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x00027C44         DC32     0x27c44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     gBootStorageStartAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0xFFFFFBEC         DC32     0xfffffbec

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     ??bitmapBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x00000401         DC32     0x401

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     __region_BOOT_ROM_end__+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     __region_BOOT_ROM_end__+0xC1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x00000414         DC32     0x414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     __region_BOOT_ROM_start__

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x40048100         DC32     0x40048100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x........         DC32     gpBootInfo
    488          //-----------------------------------------------------------------------------

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Boot_GetInternalStorageStartAddr
       8   Boot_InitExternalStorage
         8   -> EEPROM_Init
    1064   Boot_LoadImage
      1064   -> Boot_GetInternalStorageStartAddr
      1064   -> Boot_InitExternalStorage
      1064   -> Boot_ReadExternalStorage
      1064   -> Boot_ResetMCU
      1064   -> FLASH_EraseSector
      1064   -> FLASH_Program
      1064   -> FlashInitialization
      16   Boot_ReadExternalStorage
        16   -> EEPROM_ReadData
       4   Boot_ResetMCU
       4   JumpToApplication
       8   __thumb_startup
         8   -> main
       8   defaultISR
         8   -> Boot_ResetMCU
      16   main
        16   -> Boot_LoadImage
        16   -> JumpToApplication


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       6  Boot_GetInternalStorageStartAddr
      24  Boot_InitExternalStorage
     350  Boot_LoadImage
      64  Boot_ReadExternalStorage
      10  Boot_ResetMCU
      20  JumpToApplication
      12  __thumb_startup
      64  __vector_table
      32  bitmapBuffer
       8  defaultISR
       4  gBootStorageStartAddress
      16  gFlashConfig
       4  gpBootInfo
      68  main

 
  40 bytes in section .bss
 618 bytes in section .text
  16 bytes in section FlashConfig
  64 bytes in section IntVectTable
 
 618 bytes of CODE  memory
  80 bytes of CONST memory
  40 bytes of DATA  memory

Errors: none
Warnings: none
