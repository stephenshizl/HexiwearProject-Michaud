###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        12/Jan/2016  08:59:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\flash\flash_boot_kinetis.c
#    Command line =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\flash\flash_boot_kinetis.c
#        -D MCU_MKW40Z160 -D gEepromType_d=gEepromDevice_M25P80_c
#        --preprocess=cl
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\
#        -lC
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\
#        -lA
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\
#        --diag_suppress Pa039 -o
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\OtapSerialBootloader\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\spi\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\eeprom\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\flash\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\include\cfg\
#        -On --c89
#    List file    =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\flash_boot_kinetis.lst
#    Object file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\Obj\flash_boot_kinetis.o
#
###############################################################################

C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\flash\flash_boot_kinetis.c
      1          /*!
      2          * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * \file filename.h
      6          * This file brief description
      7          *
      8          * Redistribution and use in source and binary forms, with or without modification,
      9          * are permitted provided that the following conditions are met:
     10          *
     11          * o Redistributions of source code must retain the above copyright notice, this list
     12          *   of conditions and the following disclaimer.
     13          *
     14          * o Redistributions in binary form must reproduce the above copyright notice, this
     15          *   list of conditions and the following disclaimer in the documentation and/or
     16          *   other materials provided with the distribution.
     17          *
     18          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     19          *   contributors may be used to endorse or promote products derived from this
     20          *   software without specific prior written permission.
     21          *
     22          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     23          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     24          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     25          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     26          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     27          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     28          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     29          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     30          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     31          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     32          */
     33          
     34          
     35          /*! *********************************************************************************
     36          *************************************************************************************
     37          * Include
     38          *************************************************************************************
     39          ********************************************************************************** */
     40          #include "flash_boot_kinetis.h"
     41          #include "OtapBootloader.h"
     42          
     43          
     44          /*! *********************************************************************************
     45          *************************************************************************************
     46          * Private macros
     47          *************************************************************************************
     48          ********************************************************************************** */
     49          
     50          #if (gEepromParams_WriteAlignment_c > 4) 
     51              #define FLASH_PGM_SIZE (gEepromParams_WriteAlignment_c)
     52          #else
     53              #define FLASH_PGM_SIZE (4)
     54          #endif
     55          
     56          #define NoOfElements(x) (sizeof(x)/sizeof(x[0]))
     57          
     58          
     59          /*! *********************************************************************************
     60          *************************************************************************************
     61          * Private Memory Declarations
     62          *************************************************************************************
     63          ********************************************************************************** */

   \                                 In section .bss, align 4
     64          uint8_t pCommandArray[FCCOB_REGS];
   \                     pCommandArray:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     65          static FCC0B_STR CommandObj;
   \                     CommandObj:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     66          void (*ExecuteOnStack)(void) = NULL;
   \                     ExecuteOnStack:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     67          uint8_t buffer[128];
   \                     buffer:
   \   00000000                      DS8 128
     68          
     69          #if defined(__IAR_SYSTEMS_ICC__)

   \                                 In section .noinit, at 0x14000000
     70          __no_init uint32_t programbuffer[512] @0x14000000;
   \                     programbuffer:
   \   00000000                      DS8 2048
     71          #elif defined(__GNUC__)
     72          uint32_t programbuffer[512] __attribute__ ((section(".progBuffer")));
     73          #endif
     74          
     75          /*! *********************************************************************************
     76          *************************************************************************************
     77          * Private prototypes
     78          *************************************************************************************
     79          ********************************************************************************** */
     80          //  internal driver function
     81          static uint8_t FLASH_FlashCommandSequence(uint8_t index);
     82          static void ExecuteOnStackStart();
     83          
     84          
     85          /*! *********************************************************************************
     86          *************************************************************************************
     87          * Public Functions
     88          *************************************************************************************
     89          ********************************************************************************** */
     90          
     91          /********************************************************
     92          * Init Function
     93          *
     94          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
     95          void FlashInitialization(void)
     96          {
   \                     FlashInitialization: (+1)
   \   00000000   0xB500             PUSH     {LR}
     97              uint16_t i, size;
     98              
     99              //  RAM function should have the same alignment as one from ROM
    100              if( ((uint32_t)ExecuteOnStackStart - 1) & 0x03 )
   \   00000002   0x....             LDR      R2,??DataTable5
   \   00000004   0x0792             LSLS     R2,R2,#+30
   \   00000006   0xD002             BEQ      ??FlashInitialization_0
    101                  i = 2;
   \   00000008   0x2202             MOVS     R2,#+2
   \   0000000A   0x0010             MOVS     R0,R2
   \   0000000C   0xE001             B        ??FlashInitialization_1
    102              else
    103                  i = 0;
   \                     ??FlashInitialization_0: (+1)
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x0010             MOVS     R0,R2
    104              
    105              size = sizeof(buffer) - i;
   \                     ??FlashInitialization_1: (+1)
   \   00000012   0x2280             MOVS     R2,#+128
   \   00000014   0x1A12             SUBS     R2,R2,R0
   \   00000016   0x0011             MOVS     R1,R2
    106              
    107              //  initialize pointer to ram function
    108              ExecuteOnStack = (void(*)(void))&buffer[i+1];
   \   00000018   0x....             LDR      R2,??DataTable7
   \   0000001A   0xB280             UXTH     R0,R0
   \   0000001C   0x1812             ADDS     R2,R2,R0
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0x....             LDR      R3,??DataTable7_1
   \   00000022   0x601A             STR      R2,[R3, #+0]
    109              
    110              //  copy function from ROM to RAM
    111              for( ; i<size; i++ )
   \                     ??FlashInitialization_2: (+1)
   \   00000024   0xB280             UXTH     R0,R0
   \   00000026   0xB289             UXTH     R1,R1
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD209             BCS      ??FlashInitialization_3
    112                  buffer[i] = ((uint8_t*)ExecuteOnStackStart)[i-1];
   \   0000002C   0x....             LDR      R2,??DataTable7_2
   \   0000002E   0xB280             UXTH     R0,R0
   \   00000030   0x1812             ADDS     R2,R2,R0
   \   00000032   0x1E52             SUBS     R2,R2,#+1
   \   00000034   0x7812             LDRB     R2,[R2, #+0]
   \   00000036   0x....             LDR      R3,??DataTable7
   \   00000038   0xB280             UXTH     R0,R0
   \   0000003A   0x541A             STRB     R2,[R3, R0]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0xE7F1             B        ??FlashInitialization_2
    113              
    114              //  inititalization of flash clock module
    115              FLASH_INIT_FLASH_CLOCK;
   \                     ??FlashInitialization_3: (+1)
   \   00000040   0x....             LDR      R2,??DataTable8  ;; 0x4004803c
   \   00000042   0x6812             LDR      R2,[R2, #+0]
   \   00000044   0x2301             MOVS     R3,#+1
   \   00000046   0x4313             ORRS     R3,R3,R2
   \   00000048   0x....             LDR      R2,??DataTable8  ;; 0x4004803c
   \   0000004A   0x6013             STR      R3,[R2, #+0]
    116          }
   \   0000004C   0xBD00             POP      {PC}             ;; return
    117          
    118          /********************************************************
    119          * Generic FLASH programing function
    120          *
    121          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    122          uint8_t FLASH_Program(uint32_t dest, uint32_t source, uint32_t size)
    123          {
   \                     FLASH_Program: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x0014             MOVS     R4,R2
    124              uint32_t i;
    125              uint8_t* pSource = (uint8_t*)source;
   \   00000008   0x9E02             LDR      R6,[SP, #+8]
    126              uint8_t temp[FLASH_PGM_SIZE];
    127          
    128              /* Check for unaligned destination address */
    129              if (dest & (FLASH_PGM_SIZE - 0x01U))
   \   0000000A   0x07B8             LSLS     R0,R7,#+30       ;; ZeroExtS R0,R7,#+30,#+30
   \   0000000C   0x0F80             LSRS     R0,R0,#+30
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD001             BEQ      ??FLASH_Program_0
    130              {
    131                 return FLASH_FAIL;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE036             B        ??FLASH_Program_1
    132              }
    133              
    134              while( size )
   \                     ??FLASH_Program_0: (+1)
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD033             BEQ      ??FLASH_Program_2
    135              {
    136                  /* data must be multiple of FLASH_PGM_SIZE */
    137                  if( size > 0 && size < FLASH_PGM_SIZE  )
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD017             BEQ      ??FLASH_Program_3
   \   0000001E   0x2C04             CMP      R4,#+4
   \   00000020   0xD215             BCS      ??FLASH_Program_3
    138                  {
    139                      for( i=0; i<size; i++ )
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0005             MOVS     R5,R0
   \                     ??FLASH_Program_4: (+1)
   \   00000026   0x42A5             CMP      R5,R4
   \   00000028   0xD205             BCS      ??FLASH_Program_5
    140                      {
    141                          temp[i] = *pSource++;
   \   0000002A   0x7830             LDRB     R0,[R6, #+0]
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x5548             STRB     R0,[R1, R5]
   \   00000030   0x1C76             ADDS     R6,R6,#+1
    142                      }
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \   00000034   0xE7F7             B        ??FLASH_Program_4
    143                          
    144                      for( i=size; i<FLASH_PGM_SIZE; i++ )
   \                     ??FLASH_Program_5: (+1)
   \   00000036   0x0025             MOVS     R5,R4
   \                     ??FLASH_Program_6: (+1)
   \   00000038   0x2D04             CMP      R5,#+4
   \   0000003A   0xD204             BCS      ??FLASH_Program_7
    145                      {
    146                          temp[i] = 0xFF;
   \   0000003C   0x20FF             MOVS     R0,#+255
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x5548             STRB     R0,[R1, R5]
    147                      }
   \   00000042   0x1C6D             ADDS     R5,R5,#+1
   \   00000044   0xE7F8             B        ??FLASH_Program_6
    148                          
    149                      pSource = temp;
   \                     ??FLASH_Program_7: (+1)
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x0006             MOVS     R6,R0
    150                      size = FLASH_PGM_SIZE;
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0x0004             MOVS     R4,R0
    151                  }
    152                      
    153                  /* preparing passing parameter to program the flash block */
    154                  CommandObj.regsLong.fccob3210 = dest;
   \                     ??FLASH_Program_3: (+1)
   \   0000004E   0x....             LDR      R0,??DataTable10
   \   00000050   0x6007             STR      R7,[R0, #+0]
    155          #if (FLASH_PGM_SIZE==8)
    156                  CommandObj.regs.fccob0 = FLASH_PROGRAM_PHRASE;
    157                  
    158          #else
    159                  CommandObj.regs.fccob0 = FLASH_PROGRAM_LONGWORD;
   \   00000052   0x2006             MOVS     R0,#+6
   \   00000054   0x....             LDR      R1,??DataTable10
   \   00000056   0x70C8             STRB     R0,[R1, #+3]
    160          #endif
    161                  for( i=4; i<FLASH_PGM_SIZE+4; i++ )
   \   00000058   0x2004             MOVS     R0,#+4
   \   0000005A   0x0005             MOVS     R5,R0
   \                     ??FLASH_Program_8: (+1)
   \   0000005C   0x2D08             CMP      R5,#+8
   \   0000005E   0xD205             BCS      ??FLASH_Program_9
    162                  {
    163                      CommandObj.all[i] = *pSource++;
   \   00000060   0x7830             LDRB     R0,[R6, #+0]
   \   00000062   0x....             LDR      R1,??DataTable10
   \   00000064   0x5548             STRB     R0,[R1, R5]
   \   00000066   0x1C76             ADDS     R6,R6,#+1
    164                  }
   \   00000068   0x1C6D             ADDS     R5,R5,#+1
   \   0000006A   0xE7F7             B        ??FLASH_Program_8
    165          
    166                  /* calling flash command sequence function to execute the command */
    167                  if( FLASH_OK != FLASH_FlashCommandSequence(i) )
   \                     ??FLASH_Program_9: (+1)
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0xB2C0             UXTB     R0,R0
   \   00000070   0x.... 0x....      BL       FLASH_FlashCommandSequence
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD001             BEQ      ??FLASH_Program_10
    168                      return FLASH_FAIL;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0xE003             B        ??FLASH_Program_1
    169              
    170                  /* update destination address for next iteration */
    171                  dest += FLASH_PGM_SIZE;
   \                     ??FLASH_Program_10: (+1)
   \   0000007C   0x1D3F             ADDS     R7,R7,#+4
    172                  /* update size for next iteration */
    173                  size -= FLASH_PGM_SIZE;
   \   0000007E   0x1F24             SUBS     R4,R4,#+4
   \   00000080   0xE7C9             B        ??FLASH_Program_0
    174              }
    175          
    176              return FLASH_OK;
   \                     ??FLASH_Program_2: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??FLASH_Program_1: (+1)
   \   00000084   0xBDFE             POP      {R1-R7,PC}       ;; return
    177          }
    178          
    179          /********************************************************
    180          * Function for Programming multiple Long Word
    181          *
    182          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    183          uint8_t FLASH_ProgramLongWords(uint32_t destination, uint32_t source, uint32_t size)
    184          {
   \                     FLASH_ProgramLongWords: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0016             MOVS     R6,R2
    185              uint8_t ret = FLASH_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x7108             STRB     R0,[R1, #+4]
    186              uint8_t bytes;
    187              uint32_t alignedWord;
    188              uint8_t* pbSource = (uint8_t*)source;
   \   0000000E   0x9F02             LDR      R7,[SP, #+8]
    189              
    190              bytes = destination & 0x03;
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000014   0x0F80             LSRS     R0,R0,#+30
   \   00000016   0x0005             MOVS     R5,R0
    191              destination &= ~((uint32_t)0x03);
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0x4384             BICS     R4,R4,R0
    192              if( bytes )
   \   0000001C   0xB2ED             UXTB     R5,R5
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD001             BEQ      ??FLASH_ProgramLongWords_0
    193              {
    194                  /* Go to previous aligned address */
    195                  alignedWord = *((uint32_t*)destination);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x9000             STR      R0,[SP, #+0]
    196                  
    197              }
    198              while(size)
   \                     ??FLASH_ProgramLongWords_0: (+1)
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD022             BEQ      ??FLASH_ProgramLongWords_1
    199              {
    200                  ((uint8_t*)&alignedWord)[bytes] = *pbSource++;
   \   0000002A   0x7838             LDRB     R0,[R7, #+0]
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0xB2ED             UXTB     R5,R5
   \   00000030   0x5548             STRB     R0,[R1, R5]
   \   00000032   0x1C7F             ADDS     R7,R7,#+1
    201                  size--;
   \   00000034   0x1E76             SUBS     R6,R6,#+1
    202                  if((bytes == 3)||(size == 0))
   \   00000036   0xB2ED             UXTB     R5,R5
   \   00000038   0x2D03             CMP      R5,#+3
   \   0000003A   0xD001             BEQ      ??FLASH_ProgramLongWords_2
   \   0000003C   0x2E00             CMP      R6,#+0
   \   0000003E   0xD113             BNE      ??FLASH_ProgramLongWords_3
    203                  {
    204                      ret = FLASH_ProgramLongWord(destination, alignedWord);
   \                     ??FLASH_ProgramLongWords_2: (+1)
   \   00000040   0x9900             LDR      R1,[SP, #+0]
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       FLASH_ProgramLongWord
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x7108             STRB     R0,[R1, #+4]
    205                      if(FLASH_OK != ret )
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x7900             LDRB     R0,[R0, #+4]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD002             BEQ      ??FLASH_ProgramLongWords_4
    206                      {
    207                          return ret;
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x7900             LDRB     R0,[R0, #+4]
   \   00000058   0xE00B             B        ??FLASH_ProgramLongWords_5
    208                      }
    209                      if(size)
   \                     ??FLASH_ProgramLongWords_4: (+1)
   \   0000005A   0x2E00             CMP      R6,#+0
   \   0000005C   0xD004             BEQ      ??FLASH_ProgramLongWords_3
    210                      {
    211                          destination += 4;
   \   0000005E   0x1D24             ADDS     R4,R4,#+4
    212                          if(size < 4)
   \   00000060   0x2E04             CMP      R6,#+4
   \   00000062   0xD201             BCS      ??FLASH_ProgramLongWords_3
    213                          {
    214                              alignedWord = *((uint32_t*)destination);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x9000             STR      R0,[SP, #+0]
    215                          }
    216                      }
    217                  }  
    218                  bytes = (bytes+1) & 0x3;
   \                     ??FLASH_ProgramLongWords_3: (+1)
   \   00000068   0x1C6D             ADDS     R5,R5,#+1
   \   0000006A   0x07AD             LSLS     R5,R5,#+30       ;; ZeroExtS R5,R5,#+30,#+30
   \   0000006C   0x0FAD             LSRS     R5,R5,#+30
   \   0000006E   0xE7DA             B        ??FLASH_ProgramLongWords_0
    219              }
    220              
    221              
    222              return FLASH_OK;
   \                     ??FLASH_ProgramLongWords_1: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \                     ??FLASH_ProgramLongWords_5: (+1)
   \   00000072   0xBDFE             POP      {R1-R7,PC}       ;; return
    223          }
    224          /********************************************************
    225          * Function for Programming of one Long Word
    226          *
    227          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    228          uint8_t FLASH_ProgramLongWord(uint32_t destination, uint32_t data32b)
    229          {
   \                     FLASH_ProgramLongWord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    230              /* preparing passing parameter to program the flash block */
    231              
    232              CommandObj.regsLong.fccob3210 = destination;
   \   00000006   0x....             LDR      R0,??DataTable10
   \   00000008   0x6005             STR      R5,[R0, #+0]
    233              CommandObj.regs.fccob0 = FLASH_PROGRAM_LONGWORD;
   \   0000000A   0x2006             MOVS     R0,#+6
   \   0000000C   0x....             LDR      R1,??DataTable10
   \   0000000E   0x70C8             STRB     R0,[R1, #+3]
    234              CommandObj.regsLong.fccob7654 = data32b;
   \   00000010   0x....             LDR      R0,??DataTable10
   \   00000012   0x6044             STR      R4,[R0, #+4]
    235              
    236              return FLASH_FlashCommandSequence(PROGRAM_LONGWORD_INDEX);
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0x.... 0x....      BL       FLASH_FlashCommandSequence
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    237          }
    238          
    239          /********************************************************
    240          * Function for Programming of one section (maximum is 2048 Bytes)
    241          *
    242          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          uint8_t FLASH_ProgramSection(uint32_t destination, uint32_t* pSource, uint32_t size)
    244          {
   \                     FLASH_ProgramSection: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0015             MOVS     R5,R2
    245              uint8_t* pProgBuff = (uint8_t*)&programbuffer[0];
   \   00000006   0x24A0             MOVS     R4,#+160
   \   00000008   0x0564             LSLS     R4,R4,#+21       ;; #+335544320
    246              uint8_t* pSrc = (uint8_t*)pSource;
   \   0000000A   0x9F02             LDR      R7,[SP, #+8]
    247              uint32_t phases = size / FLASH_PHASE_SEZE;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x08C0             LSRS     R0,R0,#+3
   \   00000010   0x9000             STR      R0,[SP, #+0]
    248              uint8_t  r = size % FLASH_PHASE_SEZE;
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x2108             MOVS     R1,#+8
   \   00000016   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000001A   0x000E             MOVS     R6,R1
    249              
    250              // check the size of memory
    251              if((size > sizeof(programbuffer)) || (size == 0))
   \   0000001C   0x....             LDR      R0,??DataTable10_1  ;; 0x801
   \   0000001E   0x4285             CMP      R5,R0
   \   00000020   0xD201             BCS      ??FLASH_ProgramSection_0
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD101             BNE      ??FLASH_ProgramSection_1
    252                  return FLASH_FAIL;
   \                     ??FLASH_ProgramSection_0: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE030             B        ??FLASH_ProgramSection_2
    253              
    254              if(destination & 0x00000003)
   \                     ??FLASH_ProgramSection_1: (+1)
   \   0000002A   0x9801             LDR      R0,[SP, #+4]
   \   0000002C   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000002E   0x0F80             LSRS     R0,R0,#+30
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD001             BEQ      ??FLASH_ProgramSection_3
    255                  return FLASH_FAIL;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE029             B        ??FLASH_ProgramSection_2
    256              
    257              if (r > 0)
   \                     ??FLASH_ProgramSection_3: (+1)
   \   00000038   0xB2F6             UXTB     R6,R6
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD004             BEQ      ??FLASH_ProgramSection_4
    258              {
    259                  phases++;
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x9000             STR      R0,[SP, #+0]
    260                  r = FLASH_PHASE_SEZE - r;
   \   00000044   0x2008             MOVS     R0,#+8
   \   00000046   0x1B86             SUBS     R6,R0,R6
    261              }
    262              
    263              /* preparing passing parameter to program the flash block */
    264              CommandObj.regsLong.fccob3210 = destination;
   \                     ??FLASH_ProgramSection_4: (+1)
   \   00000048   0x9801             LDR      R0,[SP, #+4]
   \   0000004A   0x....             LDR      R1,??DataTable10
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    265              CommandObj.regs.fccob0 = FLASH_PROGRAM_SECTION;
   \   0000004E   0x200B             MOVS     R0,#+11
   \   00000050   0x....             LDR      R1,??DataTable10
   \   00000052   0x70C8             STRB     R0,[R1, #+3]
    266              CommandObj.regs.fccob4 = (uint8_t)(phases >> 8);
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x0A00             LSRS     R0,R0,#+8
   \   00000058   0x....             LDR      R1,??DataTable10
   \   0000005A   0x71C8             STRB     R0,[R1, #+7]
    267              CommandObj.regs.fccob5 = (uint8_t)(phases & 0xff);
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0x....             LDR      R1,??DataTable10
   \   00000060   0x7188             STRB     R0,[R1, #+6]
    268              
    269              //  copy source data to program buffer
    270              while(size--)
   \                     ??FLASH_ProgramSection_5: (+1)
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x1E45             SUBS     R5,R0,#+1
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD004             BEQ      ??FLASH_ProgramSection_6
    271                  *pProgBuff++ = *pSrc++;
   \   0000006A   0x7838             LDRB     R0,[R7, #+0]
   \   0000006C   0x7020             STRB     R0,[R4, #+0]
   \   0000006E   0x1C7F             ADDS     R7,R7,#+1
   \   00000070   0x1C64             ADDS     R4,R4,#+1
   \   00000072   0xE7F6             B        ??FLASH_ProgramSection_5
    272              
    273              while(r--)
   \                     ??FLASH_ProgramSection_6: (+1)
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0x1E46             SUBS     R6,R0,#+1
   \   00000078   0xB2C0             UXTB     R0,R0
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD003             BEQ      ??FLASH_ProgramSection_7
    274                  *pProgBuff++ = 0xFF;
   \   0000007E   0x20FF             MOVS     R0,#+255
   \   00000080   0x7020             STRB     R0,[R4, #+0]
   \   00000082   0x1C64             ADDS     R4,R4,#+1
   \   00000084   0xE7F6             B        ??FLASH_ProgramSection_6
    275              
    276              //  call flash sequence
    277              return FLASH_FlashCommandSequence(PROGRAM_SECTION_INDEX);
   \                     ??FLASH_ProgramSection_7: (+1)
   \   00000086   0x2007             MOVS     R0,#+7
   \   00000088   0x.... 0x....      BL       FLASH_FlashCommandSequence
   \                     ??FLASH_ProgramSection_2: (+1)
   \   0000008C   0xBDFE             POP      {R1-R7,PC}       ;; return
   \   0000008E                      REQUIRE programbuffer
    278          }
    279          
    280          
    281          /********************************************************
    282          * Function for Programming of one section (maximum is 2048 Bytes)
    283          *
    284          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    285          uint8_t FLASH_ProgramSectionPhrases(uint32_t destination, uint32_t* pSource, uint32_t size)
    286          {
   \                     FLASH_ProgramSectionPhrases: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x0015             MOVS     R5,R2
    287              uint8_t* pProgBuff = (uint8_t*)&programbuffer[0];
   \   00000008   0x24A0             MOVS     R4,#+160
   \   0000000A   0x0564             LSLS     R4,R4,#+21       ;; #+335544320
    288              uint8_t* pSrc = (uint8_t*)pSource;
   \   0000000C   0x9802             LDR      R0,[SP, #+8]
   \   0000000E   0x9001             STR      R0,[SP, #+4]
    289              uint32_t phases = size / FLASH_PHASE_SEZE;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x08C0             LSRS     R0,R0,#+3
   \   00000014   0x9000             STR      R0,[SP, #+0]
    290              uint8_t r = size % FLASH_PHASE_SEZE;
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x2108             MOVS     R1,#+8
   \   0000001A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000001E   0x000E             MOVS     R6,R1
    291              
    292              // check the size of memory
    293              if(size >= sizeof(programbuffer) || (size == 0))
   \   00000020   0x2080             MOVS     R0,#+128
   \   00000022   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \   00000024   0x4285             CMP      R5,R0
   \   00000026   0xD201             BCS      ??FLASH_ProgramSectionPhrases_0
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD101             BNE      ??FLASH_ProgramSectionPhrases_1
    294                  return FLASH_FAIL;
   \                     ??FLASH_ProgramSectionPhrases_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE04B             B        ??FLASH_ProgramSectionPhrases_2
    295              
    296              if(destination & 0x00000003)
   \                     ??FLASH_ProgramSectionPhrases_1: (+1)
   \   00000030   0x07B8             LSLS     R0,R7,#+30       ;; ZeroExtS R0,R7,#+30,#+30
   \   00000032   0x0F80             LSRS     R0,R0,#+30
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD00A             BEQ      ??FLASH_ProgramSectionPhrases_3
    297              {
    298                  if(size & 0x00000001)
   \   00000038   0x07E8             LSLS     R0,R5,#+31
   \   0000003A   0xD508             BPL      ??FLASH_ProgramSectionPhrases_3
    299                      if(!FLASH_ProgramLongWord(destination, *pSource))
   \   0000003C   0x9802             LDR      R0,[SP, #+8]
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0x0038             MOVS     R0,R7
   \   00000042   0x.... 0x....      BL       FLASH_ProgramLongWord
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD101             BNE      ??FLASH_ProgramSectionPhrases_3
    300                          return FLASH_FAIL;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE03C             B        ??FLASH_ProgramSectionPhrases_2
    301              }
    302              
    303              if(destination & 0x00000004)
   \                     ??FLASH_ProgramSectionPhrases_3: (+1)
   \   0000004E   0x0778             LSLS     R0,R7,#+29
   \   00000050   0xD50E             BPL      ??FLASH_ProgramSectionPhrases_4
    304              {
    305                  if(!FLASH_ProgramLongWord(destination, *pSource++))
   \   00000052   0x9802             LDR      R0,[SP, #+8]
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       FLASH_ProgramLongWord
   \   0000005C   0x9902             LDR      R1,[SP, #+8]
   \   0000005E   0x1D09             ADDS     R1,R1,#+4
   \   00000060   0x9102             STR      R1,[SP, #+8]
   \   00000062   0xB2C0             UXTB     R0,R0
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD101             BNE      ??FLASH_ProgramSectionPhrases_5
    306                      return FLASH_FAIL;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xE02D             B        ??FLASH_ProgramSectionPhrases_2
    307                  size-=4;
   \                     ??FLASH_ProgramSectionPhrases_5: (+1)
   \   0000006C   0x1F2D             SUBS     R5,R5,#+4
    308                  destination += 4;
   \   0000006E   0x1D3F             ADDS     R7,R7,#+4
    309              }
    310              
    311              if (r)
   \                     ??FLASH_ProgramSectionPhrases_4: (+1)
   \   00000070   0xB2F6             UXTB     R6,R6
   \   00000072   0x2E00             CMP      R6,#+0
   \   00000074   0xD004             BEQ      ??FLASH_ProgramSectionPhrases_6
    312              {
    313                  phases++;
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0x9000             STR      R0,[SP, #+0]
    314                  r = FLASH_PHASE_SEZE - r;
   \   0000007C   0x2008             MOVS     R0,#+8
   \   0000007E   0x1B86             SUBS     R6,R0,R6
    315              }
    316              
    317              /* preparing passing parameter to program the flash block */
    318              CommandObj.regsLong.fccob3210 = destination;
   \                     ??FLASH_ProgramSectionPhrases_6: (+1)
   \   00000080   0x....             LDR      R0,??DataTable10
   \   00000082   0x6007             STR      R7,[R0, #+0]
    319              CommandObj.regs.fccob0 = FLASH_PROGRAM_SECTION;
   \   00000084   0x200B             MOVS     R0,#+11
   \   00000086   0x....             LDR      R1,??DataTable10
   \   00000088   0x70C8             STRB     R0,[R1, #+3]
    320              CommandObj.regs.fccob4 = (uint8_t)(phases >> 8);
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0x0A00             LSRS     R0,R0,#+8
   \   0000008E   0x....             LDR      R1,??DataTable10
   \   00000090   0x71C8             STRB     R0,[R1, #+7]
    321              CommandObj.regs.fccob5 = (uint8_t)(phases & 0xff);
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x....             LDR      R1,??DataTable10
   \   00000096   0x7188             STRB     R0,[R1, #+6]
    322              
    323              //  copy source data to program buffer
    324              while(size--)
   \                     ??FLASH_ProgramSectionPhrases_7: (+1)
   \   00000098   0x0028             MOVS     R0,R5
   \   0000009A   0x1E45             SUBS     R5,R0,#+1
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD007             BEQ      ??FLASH_ProgramSectionPhrases_8
    325                  *pProgBuff++ = *pSrc++;
   \   000000A0   0x9801             LDR      R0,[SP, #+4]
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x7020             STRB     R0,[R4, #+0]
   \   000000A6   0x9801             LDR      R0,[SP, #+4]
   \   000000A8   0x1C40             ADDS     R0,R0,#+1
   \   000000AA   0x9001             STR      R0,[SP, #+4]
   \   000000AC   0x1C64             ADDS     R4,R4,#+1
   \   000000AE   0xE7F3             B        ??FLASH_ProgramSectionPhrases_7
    326              
    327              while(r--)
   \                     ??FLASH_ProgramSectionPhrases_8: (+1)
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0x1E46             SUBS     R6,R0,#+1
   \   000000B4   0xB2C0             UXTB     R0,R0
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD003             BEQ      ??FLASH_ProgramSectionPhrases_9
    328                  *pProgBuff++ = 0xFF;
   \   000000BA   0x20FF             MOVS     R0,#+255
   \   000000BC   0x7020             STRB     R0,[R4, #+0]
   \   000000BE   0x1C64             ADDS     R4,R4,#+1
   \   000000C0   0xE7F6             B        ??FLASH_ProgramSectionPhrases_8
    329              
    330              //  call flash sequence
    331              return FLASH_FlashCommandSequence(PROGRAM_SECTION_INDEX);
   \                     ??FLASH_ProgramSectionPhrases_9: (+1)
   \   000000C2   0x2007             MOVS     R0,#+7
   \   000000C4   0x.... 0x....      BL       FLASH_FlashCommandSequence
   \                     ??FLASH_ProgramSectionPhrases_2: (+1)
   \   000000C8   0xBDFE             POP      {R1-R7,PC}       ;; return
   \   000000CA                      REQUIRE programbuffer
    332          }
    333          
    334          /********************************************************
    335          *
    336          *
    337          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    338          uint8_t FLASH_ProgramByte(uint32_t destination, uint8_t data8b)
    339          {
   \                     FLASH_ProgramByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    340              CommandObj.regsLong.fccob3210 = destination;
   \   00000006   0x....             LDR      R0,??DataTable10
   \   00000008   0x6005             STR      R5,[R0, #+0]
    341              CommandObj.regs.fccob0 = FLASH_PROGRAM_BYTE;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0x....             LDR      R1,??DataTable10
   \   0000000E   0x70C8             STRB     R0,[R1, #+3]
    342              CommandObj.regs.fccob4 = data8b;
   \   00000010   0x....             LDR      R0,??DataTable10
   \   00000012   0x71C4             STRB     R4,[R0, #+7]
    343              
    344              return FLASH_FlashCommandSequence(PROGRAM_BYTE_INDEX);
   \   00000014   0x2005             MOVS     R0,#+5
   \   00000016   0x.... 0x....      BL       FLASH_FlashCommandSequence
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    345          }
    346          
    347          /********************************************************
    348          * Function for erasing of flash memory sector (0x800)
    349          *
    350          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    351          uint8_t FLASH_EraseSector(uint32_t destination)
    352          {
   \                     FLASH_EraseSector: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    353              CommandObj.regsLong.fccob3210 = destination;
   \   00000004   0x....             LDR      R0,??DataTable10
   \   00000006   0x6004             STR      R4,[R0, #+0]
    354              CommandObj.regs.fccob0 = FLASH_ERASE_SECTOR;
   \   00000008   0x2009             MOVS     R0,#+9
   \   0000000A   0x....             LDR      R1,??DataTable10
   \   0000000C   0x70C8             STRB     R0,[R1, #+3]
    355              
    356              return FLASH_FlashCommandSequence(ERASE_BLOCK_INDEX);
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x.... 0x....      BL       FLASH_FlashCommandSequence
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    357          }
    358          
    359          
    360          /********************************************************
    361          * Function for erasing of all block of memory
    362          *
    363          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    364          uint8_t FLASH_MassErase(void)
    365          {
   \                     FLASH_MassErase: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    366              CommandObj.regs.fccob0 = FLASH_ERASE_ALL_BLOCK;
   \   00000002   0x2044             MOVS     R0,#+68
   \   00000004   0x....             LDR      R1,??DataTable10
   \   00000006   0x70C8             STRB     R0,[R1, #+3]
    367              return FLASH_FlashCommandSequence(ERASE_MASS_INDEX);
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x.... 0x....      BL       FLASH_FlashCommandSequence
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    368          }
    369          
    370          /********************************************************
    371          * Function for enabling the EERAM
    372          *
    373          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    374          uint8_t FLASH_SetEEEEnable(uint8_t ctrl_code)
    375          {
   \                     FLASH_SetEEEEnable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    376              CommandObj.regs.fccob0 = FLASH_SET_EERAM;
   \   00000004   0x2081             MOVS     R0,#+129
   \   00000006   0x....             LDR      R1,??DataTable10
   \   00000008   0x70C8             STRB     R0,[R1, #+3]
    377              CommandObj.regs.fccob1 = ctrl_code;
   \   0000000A   0x....             LDR      R0,??DataTable10
   \   0000000C   0x7084             STRB     R4,[R0, #+2]
    378              return FLASH_FlashCommandSequence(SET_EERAM_INDEX);
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x.... 0x....      BL       FLASH_FlashCommandSequence
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    379          }
    380          
    381          
    382          /*! *********************************************************************************
    383          *************************************************************************************
    384          * Private Functions
    385          *************************************************************************************
    386          ********************************************************************************** */
    387          
    388          /********************************************************
    389          * Function for executing of the flash command
    390          *
    391          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    392          static uint8_t FLASH_FlashCommandSequence(uint8_t index)
    393          {
   \                     FLASH_FlashCommandSequence: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    394              uint8_t* ptrFccobReg = (uint8_t*)&FLASH_BASE_PTR->FCCOB3;
   \   00000004   0x....             LDR      R4,??DataTable10_2  ;; 0x40020004
    395              uint8_t* ptrCommandObj = (uint8_t*)&CommandObj;
   \   00000006   0x....             LDR      R5,??DataTable10
    396              
    397              
    398              /* wait till CCIF bit is set */
    399              while((FLASH_FSTAT&FLASH_FSTAT_CCIF_MASK) != FLASH_FSTAT_CCIF_MASK){};
   \                     ??FLASH_FlashCommandSequence_0: (+1)
   \   00000008   0x....             LDR      R0,??DataTable10_3  ;; 0x40020000
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x0600             LSLS     R0,R0,#+24
   \   00000010   0xD5FA             BPL      ??FLASH_FlashCommandSequence_0
    400              
    401              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
    402              FLASH_FSTAT = FLASH_FSTAT_ACCERR_MASK|FLASH_FSTAT_FPVIOL_MASK|FLASH_FSTAT_RDCOLERR_MASK;
   \   00000012   0x2070             MOVS     R0,#+112
   \   00000014   0x....             LDR      R1,??DataTable10_3  ;; 0x40020000
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    403              
    404              /* load FCCOB registers */
    405              while(index--)
   \                     ??FLASH_FlashCommandSequence_1: (+1)
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x1E46             SUBS     R6,R0,#+1
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD004             BEQ      ??FLASH_FlashCommandSequence_2
    406                  *ptrFccobReg++ = *ptrCommandObj++;
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0x7020             STRB     R0,[R4, #+0]
   \   00000026   0x1C6D             ADDS     R5,R5,#+1
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \   0000002A   0xE7F5             B        ??FLASH_FlashCommandSequence_1
    407              
    408              //  jump to RAM function
    409              ExecuteOnStack();
   \                     ??FLASH_FlashCommandSequence_2: (+1)
   \   0000002C   0x....             LDR      R0,??DataTable10_4
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x4780             BLX      R0
    410              
    411              /* Check error bits */
    412              /* Get flash status register value */
    413              if(FLASH_FSTAT & (FLASH_FSTAT_ACCERR_MASK|FLASH_FSTAT_FPVIOL_MASK|FLASH_FSTAT_MGSTAT0_MASK))
   \   00000032   0x....             LDR      R0,??DataTable10_3  ;; 0x40020000
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2131             MOVS     R1,#+49
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD001             BEQ      ??FLASH_FlashCommandSequence_3
    414                  return FLASH_FAIL;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE000             B        ??FLASH_FlashCommandSequence_4
    415              
    416              return FLASH_OK;
   \                     ??FLASH_FlashCommandSequence_3: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??FLASH_FlashCommandSequence_4: (+1)
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    417          }
    418          
    419          /********************************************************
    420          * Function for lounching a FLASH command: will run from RAM
    421          *
    422          ********************************************************/

   \                                 In section .text, align 2, keep-with-next
    423          static void ExecuteOnStackStart(void)
    424          {
   \                     ExecuteOnStackStart: (+1)
   \   00000000   0xB500             PUSH     {LR}
    425              //  launch a command
    426              FLASH_FSTAT |= FLASH_FSTAT_CCIF_MASK;
   \   00000002   0x....             LDR      R0,??DataTable10_3  ;; 0x40020000
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2180             MOVS     R1,#+128
   \   00000008   0x4301             ORRS     R1,R1,R0
   \   0000000A   0x....             LDR      R0,??DataTable10_3  ;; 0x40020000
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    427              
    428              //  waiting for the finishing of the command
    429              while((FLASH_FSTAT&FLASH_FSTAT_CCIF_MASK) != FLASH_FSTAT_CCIF_MASK){};
   \                     ??ExecuteOnStackStart_0: (+1)
   \   0000000E   0x....             LDR      R0,??DataTable10_3  ;; 0x40020000
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x0600             LSLS     R0,R0,#+24
   \   00000016   0xD5FA             BPL      ??ExecuteOnStackStart_0
    430          }
   \   00000018   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     ExecuteOnStackStart+0xFFFFFFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     ExecuteOnStack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     ExecuteOnStackStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     CommandObj

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x00000801         DC32     0x801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40020004         DC32     0x40020004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     ExecuteOnStack

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   ExecuteOnStackStart
       8   FLASH_EraseSector
         8   -> FLASH_FlashCommandSequence
      16   FLASH_FlashCommandSequence
        16   -- Indirect call
       8   FLASH_MassErase
         8   -> FLASH_FlashCommandSequence
      32   FLASH_Program
        32   -> FLASH_FlashCommandSequence
      16   FLASH_ProgramByte
        16   -> FLASH_FlashCommandSequence
      16   FLASH_ProgramLongWord
        16   -> FLASH_FlashCommandSequence
      32   FLASH_ProgramLongWords
        32   -> FLASH_ProgramLongWord
      32   FLASH_ProgramSection
        32   -> FLASH_FlashCommandSequence
        32 __aeabi_uidivmod
      32   FLASH_ProgramSectionPhrases
        32   -> FLASH_FlashCommandSequence
        32   -> FLASH_ProgramLongWord
        32 __aeabi_uidivmod
       8   FLASH_SetEEEEnable
         8   -> FLASH_FlashCommandSequence
       4   FlashInitialization


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable5
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable8
      12  CommandObj
       4  ExecuteOnStack
      26  ExecuteOnStackStart
      22  FLASH_EraseSector
      68  FLASH_FlashCommandSequence
      16  FLASH_MassErase
     134  FLASH_Program
      28  FLASH_ProgramByte
      28  FLASH_ProgramLongWord
     116  FLASH_ProgramLongWords
     142  FLASH_ProgramSection
     202  FLASH_ProgramSectionPhrases
      22  FLASH_SetEEEEnable
      78  FlashInitialization
     128  buffer
      12  pCommandArray
    2048  programbuffer

 
   156 bytes in section .bss
 2 048 bytes in section .noinit (abs)
   922 bytes in section .text
 
 922 bytes of CODE memory
 156 bytes of DATA memory (+ 2 048 bytes shared)

Errors: none
Warnings: none
