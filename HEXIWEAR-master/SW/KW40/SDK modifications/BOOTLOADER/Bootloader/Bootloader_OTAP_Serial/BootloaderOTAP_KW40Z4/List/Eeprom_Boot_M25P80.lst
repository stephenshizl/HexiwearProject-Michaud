###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        12/Jan/2016  08:59:55
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\eeprom\Eeprom_Boot_M25P80.c
#    Command line =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\eeprom\Eeprom_Boot_M25P80.c
#        -D MCU_MKW40Z160 -D gEepromType_d=gEepromDevice_M25P80_c
#        --preprocess=cl
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\
#        -lC
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\
#        -lA
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\
#        --diag_suppress Pa039 -o
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\OtapSerialBootloader\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\spi\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\eeprom\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\flash\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\include\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\
#        -I
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\include\cfg\
#        -On --c89
#    List file    =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\List\Eeprom_Boot_M25P80.lst
#    Object file  =  
#        C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\BootloaderOTAP_KW40Z4\Obj\Eeprom_Boot_M25P80.o
#
###############################################################################

C:\Freescale\KW40Z_Connectivity_Software_1.0.1\ConnSw\framework\Bootloader\Bootloader_OTAP_Serial\src\eeprom\Eeprom_Boot_M25P80.c
      1          /*!
      2          * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3          * All rights reserved.
      4          *
      5          * \file EEPROM_InternalFlash.c
      6          * This is the Source file for the EEPROM emulated inside the MCU's FLASH
      7          *
      8          * Redistribution and use in source and binary forms, with or without modification,
      9          * are permitted provided that the following conditions are met:
     10          *
     11          * o Redistributions of source code must retain the above copyright notice, this list
     12          *   of conditions and the following disclaimer.
     13          *
     14          * o Redistributions in binary form must reproduce the above copyright notice, this
     15          *   list of conditions and the following disclaimer in the documentation and/or
     16          *   other materials provided with the distribution.
     17          *
     18          * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     19          *   contributors may be used to endorse or promote products derived from this
     20          *   software without specific prior written permission.
     21          *
     22          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     23          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     24          * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     25          * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     26          * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     27          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     28          * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     29          * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     30          * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     31          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     32          */
     33          
     34          #include "Eeprom_Boot.h"
     35          
     36          #if gEepromType_d == gEepromDevice_M25P80_c
     37          
     38          #include "SPI.h"
     39          
     40          

   \                                 In section .bss, align 1
     41          static uint8_t currentStatus;
   \                     currentStatus:
   \   00000000                      DS8 1
     42          
     43          /**
     44           * macros
     45           */
     46          
     47          #define EEPROM_IsWriteInProgress()    ( 0 != ( ( currentStatus & EEPROM_BIT_WIP_MASK ) >> EEPROM_BIT_WIP_SHIFT ) )
     48          #define EEPROM_IsWriteNotInProgress() ( 0 == ( ( currentStatus & EEPROM_BIT_WIP_MASK ) >> EEPROM_BIT_WIP_SHIFT ) )
     49          #define EEPROM_IsWriteEnabled()       ( 0 != ( ( currentStatus & EEPROM_BIT_WEL_MASK ) >> EEPROM_BIT_WEL_SHIFT ) )
     50          #define EEPROM_IsWriteNotEnabled()    ( 0 == ( ( currentStatus & EEPROM_BIT_WEL_MASK ) >> EEPROM_BIT_WEL_SHIFT ) )
     51          
     52          
     53          /*! *********************************************************************************
     54          *************************************************************************************
     55          * Private macros
     56          *************************************************************************************
     57          ********************************************************************************** */
     58          #define  gEepromWriteEnable_d   1
     59          
     60          /**
     61           * designate the end of the command
     62           */
     63          #define EEPROM_CMD_CNT (0) // continue
     64          #define EEPROM_CMD_END (1) // end with this command
     65          
     66          // WRITE ENABLE command must be executed before PROGRAM, ERASE, and WRITE command
     67          #define EEPROM_CMD_WRITE_ENABLE  ( 0x06 )
     68          #define EEPROM_CMD_WRITE_DISABLE ( 0x04 )
     69          #define EEPROM_CMD_WRITE_STATUS  ( 0x01 )
     70          
     71          #define EEPROM_CMD_READ_IDENTIFICATION ( 0x9F )
     72          #define EEPROM_CMD_READ_STATUS         ( 0x05 )
     73          #define EEPROM_CMD_READ_DATA_BYTES     ( 0x03 )
     74          #define EEPROM_CMD_READ_DATA_BYTES_HS  ( 0x0B )
     75          
     76          #define EEPROM_CMD_PROGRAM_PAGE ( 0x02  )
     77          #define EEPROM_PAGE_SIZE        (256)
     78          #define EEPROM_PAGE_MASK        (EEPROM_PAGE_SIZE - 1)
     79          #define EEPROM_SECTOR_SIZE      (EEPROM_PAGE_SIZE * 256)
     80          
     81          #define EEPROM_CMD_ERASE_SECTOR ( 0xD8 )
     82          #define EEPROM_CMD_ERASE_BULK   ( 0xC7 )
     83          
     84          #define EEPROM_CMD_DEEP_PWR_DOWN     ( 0xB9 )
     85          #define EEPROM_CMD_DEEP_PWR_DOWN_RLS ( 0xAB )
     86          
     87          /**
     88           * EEPROM bits
     89           */
     90          
     91          #define EEPROM_BIT_WIP_SHIFT ( 0 )
     92          #define EEPROM_BIT_WEL_SHIFT ( 1 )
     93          
     94          #define EEPROM_BIT_WIP_MASK  ( 1 << EEPROM_BIT_WIP_SHIFT )
     95          #define EEPROM_BIT_WEL_MASK  ( 1 << EEPROM_BIT_WEL_SHIFT )
     96          
     97          
     98          /* SPI config */
     99          #define gEepromSpiInstance_c  1
    100          #define gEepromSpiCsPin_d     GPIO_MAKE_PIN(GPIOA_IDX, 19)
    101          
    102          #define gEepromAssertCS_d()   assert_cs()
    103          #define gEepromDeassertCS_d() deassert_cs()
    104          
    105          /****************************** SPI MACROS ***********************************/
    106          #define mEepromSpiInstance_c 1
    107          
    108          /******************************************************************************
    109          *******************************************************************************
    110          * Private Prototypes
    111          *******************************************************************************
    112          ******************************************************************************/
    113          static ee_err_t EEPROM_SendCmd(const uint8_t cmdToSend, uint8_t  endFlag);
    114          static ee_err_t EEPROM_GetWriteReady();
    115          static ee_err_t EEPROM_SendAddress(uint32_t eepromAddress);
    116          static ee_err_t EEPROM_WritePage(uint32_t NoOfBytes, uint32_t Addr, uint8_t *Outbuf);
    117          static ee_err_t EEPROM_PrepareForWrite(uint32_t NoOfBytes, uint32_t Addr);
    118          
    119          
    120          /*! *********************************************************************************
    121          *************************************************************************************
    122          * Private Memory Declarations
    123          *************************************************************************************
    124          ********************************************************************************** */
    125          
    126          #if gEepromWriteEnable_d

   \                                 In section .bss, align 4
    127          static uint8_t mEepromEraseBitmap[64];
   \                     mEepromEraseBitmap:
   \   00000000                      DS8 64
    128          #endif
    129          
    130          
    131          /*! *********************************************************************************
    132          *************************************************************************************
    133          * Public Functions
    134          *************************************************************************************
    135          ********************************************************************************** */
    136          
    137          /*****************************************************************************
    138          *  EEPROM_Init
    139          *
    140          *  Initializes the EEPROM peripheral
    141          *
    142          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    143          ee_err_t EEPROM_Init(void)
    144          {   
   \                     EEPROM_Init: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    145              spi_user_config_t config;
    146              
    147          #if gEepromWriteEnable_d
    148              uint32_t i;
    149          
    150              // Mark Flash as Unerased
    151              for(i = 0; i < 64; i++)
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x0004             MOVS     R4,R0
   \                     ??EEPROM_Init_0: (+1)
   \   00000006   0x2C40             CMP      R4,#+64
   \   00000008   0xD204             BCS      ??EEPROM_Init_1
    152                  mEepromEraseBitmap[i] = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x....             LDR      R1,??DataTable6
   \   0000000E   0x5508             STRB     R0,[R1, R4]
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \   00000012   0xE7F8             B        ??EEPROM_Init_0
    153          #endif
    154          
    155              config.busFrequencyKHz = 8000;
   \                     ??EEPROM_Init_1: (+1)
   \   00000014   0x20FA             MOVS     R0,#+250
   \   00000016   0x0140             LSLS     R0,R0,#+5        ;; #+8000
   \   00000018   0x9000             STR      R0,[SP, #+0]
    156              config.direction = kSpiMsbFirst;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4669             MOV      R1,SP
   \   0000001E   0x7188             STRB     R0,[R1, #+6]
    157              config.phase = kSpiClockPhase_FirstEdge;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x7148             STRB     R0,[R1, #+5]
    158              config.polarity = kSpiClockPolarity_ActiveHigh;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x7108             STRB     R0,[R1, #+4]
    159              
    160              spi_master_init(mEepromSpiInstance_c);
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      BL       spi_master_init
    161              spi_master_configure_bus(mEepromSpiInstance_c, &config);
   \   00000032   0x4669             MOV      R1,SP
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x.... 0x....      BL       spi_master_configure_bus
    162              
    163              gEepromDeassertCS_d(); 
   \   0000003A   0x....             LDR      R0,??DataTable6_1  ;; 0x400ff004
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2180             MOVS     R1,#+128
   \   00000040   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   00000042   0x4301             ORRS     R1,R1,R0
   \   00000044   0x....             LDR      R0,??DataTable6_1  ;; 0x400ff004
   \   00000046   0x6001             STR      R1,[R0, #+0]
    164              
    165              return ee_ok;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    166          }
    167          
    168          /*****************************************************************************
    169          *  EEPROM_ChipErase
    170          *
    171          *  Erase all memory to 0xFF
    172          *
    173          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    174          ee_err_t EEPROM_ChipErase(void)
    175          {
   \                     EEPROM_ChipErase: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    176              // make sure the write process is ready
    177              while(EEPROM_GetWriteReady() != ee_ok);
   \                     ??EEPROM_ChipErase_0: (+1)
   \   00000002   0x.... 0x....      BL       EEPROM_GetWriteReady
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD1FB             BNE      ??EEPROM_ChipErase_0
    178              
    179              return EEPROM_SendCmd(EEPROM_CMD_ERASE_BULK, EEPROM_CMD_END);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x20C7             MOVS     R0,#+199
   \   0000000E   0x.... 0x....      BL       EEPROM_SendCmd
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    180          }
    181          
    182          /*****************************************************************************
    183          *  EEPROM_EraseBlock
    184          *
    185          *  Erase a block of memory to 0xFF
    186          *
    187          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    188          ee_err_t EEPROM_EraseBlock(uint32_t Addr, uint32_t size)
    189          {
   \                     EEPROM_EraseBlock: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
    190              ee_err_t status = ee_ok;
   \   00000006   0x2500             MOVS     R5,#+0
    191              
    192              if(size != EEPROM_SECTOR_SIZE)
   \   00000008   0x2080             MOVS     R0,#+128
   \   0000000A   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD001             BEQ      ??EEPROM_EraseBlock_0
    193              {
    194                  return ee_error;
   \   00000010   0x2004             MOVS     R0,#+4
   \   00000012   0xE01B             B        ??EEPROM_EraseBlock_1
    195              }
    196              
    197              // make sure the write process is ready
    198              while(EEPROM_GetWriteReady() != ee_ok);
   \                     ??EEPROM_EraseBlock_0: (+1)
   \   00000014   0x.... 0x....      BL       EEPROM_GetWriteReady
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1FB             BNE      ??EEPROM_EraseBlock_0
    199              
    200              // send the command
    201              status |= EEPROM_SendCmd( EEPROM_CMD_ERASE_SECTOR, EEPROM_CMD_CNT );
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x20D8             MOVS     R0,#+216
   \   00000020   0x.... 0x....      BL       EEPROM_SendCmd
   \   00000024   0x4328             ORRS     R0,R0,R5
   \   00000026   0x0005             MOVS     R5,R0
    202              
    203              // send the address
    204              status |= EEPROM_SendAddress(Addr);
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       EEPROM_SendAddress
   \   0000002E   0x4328             ORRS     R0,R0,R5
   \   00000030   0x0005             MOVS     R5,R0
    205          
    206              if (status == ee_ok)
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD108             BNE      ??EEPROM_EraseBlock_2
    207              {
    208                  gEepromDeassertCS_d();
   \   00000038   0x....             LDR      R0,??DataTable6_1  ;; 0x400ff004
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x2180             MOVS     R1,#+128
   \   0000003E   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   00000040   0x4301             ORRS     R1,R1,R0
   \   00000042   0x....             LDR      R0,??DataTable6_1  ;; 0x400ff004
   \   00000044   0x6001             STR      R1,[R0, #+0]
    209                  return ee_ok;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE000             B        ??EEPROM_EraseBlock_1
    210              }
    211              else
    212              {
    213                  return ee_error;
   \                     ??EEPROM_EraseBlock_2: (+1)
   \   0000004A   0x2004             MOVS     R0,#+4
   \                     ??EEPROM_EraseBlock_1: (+1)
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
    214              }
    215          }
    216          
    217          /*****************************************************************************
    218          *  EEPROM_WriteData
    219          *
    220          *  Writes a data buffer into EEPROM, at a given address
    221          *
    222          *****************************************************************************/
    223          #if gEepromWriteEnable_d

   \                                 In section .text, align 2, keep-with-next
    224          ee_err_t EEPROM_WriteData(uint32_t NoOfBytes, uint32_t Addr, uint8_t *Outbuf)
    225          {
   \                     EEPROM_WriteData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    226              ee_err_t status = ee_ok;
   \   00000008   0x2700             MOVS     R7,#+0
    227              
    228              if (NoOfBytes == 0)
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD102             BNE      ??EEPROM_WriteData_0
    229              {
    230                  return status;
   \   0000000E   0x0038             MOVS     R0,R7
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0xE031             B        ??EEPROM_WriteData_1
    231              }
    232              
    233              // make sure the write process is ready
    234              while(EEPROM_GetWriteReady() != ee_ok);
   \                     ??EEPROM_WriteData_0: (+1)
   \   00000014   0x.... 0x....      BL       EEPROM_GetWriteReady
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1FB             BNE      ??EEPROM_WriteData_0
    235              
    236              status = EEPROM_PrepareForWrite(NoOfBytes, Addr);
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       EEPROM_PrepareForWrite
   \   00000024   0x0007             MOVS     R7,R0
    237              if (status != ee_ok)
   \   00000026   0xB2FF             UXTB     R7,R7
   \   00000028   0x2F00             CMP      R7,#+0
   \   0000002A   0xD002             BEQ      ??EEPROM_WriteData_2
    238              {
    239                  return status;
   \   0000002C   0x0038             MOVS     R0,R7
   \   0000002E   0xB2C0             UXTB     R0,R0
   \   00000030   0xE022             B        ??EEPROM_WriteData_1
    240              }
    241              
    242              while ((Addr & EEPROM_PAGE_MASK) + NoOfBytes > EEPROM_PAGE_MASK)
   \                     ??EEPROM_WriteData_2: (+1)
   \   00000032   0xB2E8             UXTB     R0,R5
   \   00000034   0x1900             ADDS     R0,R0,R4
   \   00000036   0x28FF             CMP      R0,#+255
   \   00000038   0xD916             BLS      ??EEPROM_WriteData_3
    243              {
    244                  uint32_t bytes = EEPROM_PAGE_SIZE - (Addr & EEPROM_PAGE_MASK);
   \   0000003A   0x2080             MOVS     R0,#+128
   \   0000003C   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \   0000003E   0xB2E9             UXTB     R1,R5
   \   00000040   0x1A40             SUBS     R0,R0,R1
   \   00000042   0x9000             STR      R0,[SP, #+0]
    245                  
    246                  status = EEPROM_WritePage(bytes, Addr, Outbuf);
   \   00000044   0x0032             MOVS     R2,R6
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x.... 0x....      BL       EEPROM_WritePage
   \   0000004E   0x0007             MOVS     R7,R0
    247                  NoOfBytes -= bytes;
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x1A24             SUBS     R4,R4,R0
    248                  Addr += bytes;
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x182D             ADDS     R5,R5,R0
    249                  Outbuf += bytes;
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0x1836             ADDS     R6,R6,R0
    250                  
    251                  if (status != ee_ok)
   \   0000005C   0xB2FF             UXTB     R7,R7
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xD0E7             BEQ      ??EEPROM_WriteData_2
    252                      return status;
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0xB2C0             UXTB     R0,R0
   \   00000066   0xE007             B        ??EEPROM_WriteData_1
    253              }
    254              
    255              status = EEPROM_WritePage(NoOfBytes, Addr, Outbuf);
   \                     ??EEPROM_WriteData_3: (+1)
   \   00000068   0x0032             MOVS     R2,R6
   \   0000006A   0x0029             MOVS     R1,R5
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       EEPROM_WritePage
   \   00000072   0x0007             MOVS     R7,R0
    256              
    257              return status;
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0xB2C0             UXTB     R0,R0
   \                     ??EEPROM_WriteData_1: (+1)
   \   00000078   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    258          }
    259          #endif
    260          
    261          /*****************************************************************************
    262          *  EEPROM_WriteData
    263          *
    264          *  Writes a data buffer into the External Memory, at a given address
    265          *
    266          *****************************************************************************/
    267          #if gEepromWriteEnable_d

   \                                 In section .text, align 2, keep-with-next
    268          static ee_err_t EEPROM_PrepareForWrite(uint32_t NoOfBytes, uint32_t Addr)
    269          {
   \                     EEPROM_PrepareForWrite: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x000E             MOVS     R6,R1
    270              uint32_t i;
    271              ee_err_t ret = ee_ok;
   \   00000008   0x2500             MOVS     R5,#+0
    272              uint32_t startBlk, endBlk;
    273              
    274              // Obtain the block number
    275              startBlk = Addr / EEPROM_SECTOR_SIZE;
   \   0000000A   0x0030             MOVS     R0,R6
   \   0000000C   0x0C00             LSRS     R0,R0,#+16
   \   0000000E   0x9003             STR      R0,[SP, #+12]
    276              endBlk   = (Addr + NoOfBytes) / EEPROM_SECTOR_SIZE + 1;
   \   00000010   0x19F0             ADDS     R0,R6,R7
   \   00000012   0x0C00             LSRS     R0,R0,#+16
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x9002             STR      R0,[SP, #+8]
    277              
    278              for(i = startBlk; i <= endBlk; i++)
   \   00000018   0x9803             LDR      R0,[SP, #+12]
   \   0000001A   0x0004             MOVS     R4,R0
   \                     ??EEPROM_PrepareForWrite_0: (+1)
   \   0000001C   0x9802             LDR      R0,[SP, #+8]
   \   0000001E   0x42A0             CMP      R0,R4
   \   00000020   0xD336             BCC      ??EEPROM_PrepareForWrite_1
    279              {
    280                  if ( (mEepromEraseBitmap[i/8] & (1 << (i%8) ) ) == 0)
   \   00000022   0x....             LDR      R0,??DataTable6
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0x08C9             LSRS     R1,R1,#+3
   \   00000028   0x5C41             LDRB     R1,[R0, R1]
   \   0000002A   0x9101             STR      R1,[SP, #+4]
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x2108             MOVS     R1,#+8
   \   00000034   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x4088             LSLS     R0,R0,R1
   \   0000003C   0x9901             LDR      R1,[SP, #+4]
   \   0000003E   0x4201             TST      R1,R0
   \   00000040   0xD124             BNE      ??EEPROM_PrepareForWrite_2
    281                  {
    282                      ret = EEPROM_EraseBlock(i * EEPROM_SECTOR_SIZE, EEPROM_SECTOR_SIZE);
   \   00000042   0x2180             MOVS     R1,#+128
   \   00000044   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000046   0x2080             MOVS     R0,#+128
   \   00000048   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   0000004A   0x4360             MULS     R0,R4,R0
   \   0000004C   0x.... 0x....      BL       EEPROM_EraseBlock
   \   00000050   0x0005             MOVS     R5,R0
    283                      if (ret != ee_ok)
   \   00000052   0xB2ED             UXTB     R5,R5
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD002             BEQ      ??EEPROM_PrepareForWrite_3
    284                          return ret;
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0xB2C0             UXTB     R0,R0
   \   0000005C   0xE01A             B        ??EEPROM_PrepareForWrite_4
    285                      
    286                      mEepromEraseBitmap[i/8] |= 1 << (i%8);
   \                     ??EEPROM_PrepareForWrite_3: (+1)
   \   0000005E   0x....             LDR      R0,??DataTable6
   \   00000060   0x0021             MOVS     R1,R4
   \   00000062   0x08C9             LSRS     R1,R1,#+3
   \   00000064   0x5C41             LDRB     R1,[R0, R1]
   \   00000066   0x9101             STR      R1,[SP, #+4]
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x2108             MOVS     R1,#+8
   \   00000070   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x4088             LSLS     R0,R0,R1
   \   00000078   0x9901             LDR      R1,[SP, #+4]
   \   0000007A   0x4308             ORRS     R0,R0,R1
   \   0000007C   0x....             LDR      R1,??DataTable6
   \   0000007E   0x0022             MOVS     R2,R4
   \   00000080   0x08D2             LSRS     R2,R2,#+3
   \   00000082   0x5488             STRB     R0,[R1, R2]
    287                      while (EEPROM_isBusy());
   \                     ??EEPROM_PrepareForWrite_5: (+1)
   \   00000084   0x.... 0x....      BL       EEPROM_isBusy
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD1FB             BNE      ??EEPROM_PrepareForWrite_5
    288                  }
    289              }
   \                     ??EEPROM_PrepareForWrite_2: (+1)
   \   0000008C   0x1C64             ADDS     R4,R4,#+1
   \   0000008E   0xE7C5             B        ??EEPROM_PrepareForWrite_0
    290          
    291              return ret;
   \                     ??EEPROM_PrepareForWrite_1: (+1)
   \   00000090   0x0028             MOVS     R0,R5
   \   00000092   0xB2C0             UXTB     R0,R0
   \                     ??EEPROM_PrepareForWrite_4: (+1)
   \   00000094   0xB005             ADD      SP,SP,#+20
   \   00000096   0xBDF0             POP      {R4-R7,PC}       ;; return
    292          }
    293          #endif
    294          
    295          #if gEepromWriteEnable_d

   \                                 In section .text, align 2, keep-with-next
    296          static ee_err_t EEPROM_WritePage(uint32_t NoOfBytes, uint32_t Addr, uint8_t *Outbuf)
    297          {
   \                     EEPROM_WritePage: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
    298              ee_err_t status = ee_ok;
   \   00000008   0x2400             MOVS     R4,#+0
    299              
    300              if (NoOfBytes == 0)
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD101             BNE      ??EEPROM_WritePage_0
    301              {
    302                  return ee_ok;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE033             B        ??EEPROM_WritePage_1
    303              }
    304              
    305              // make sure the write process is ready
    306              while(EEPROM_GetWriteReady() != ee_ok);
   \                     ??EEPROM_WritePage_0: (+1)
   \   00000012   0x.... 0x....      BL       EEPROM_GetWriteReady
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1FB             BNE      ??EEPROM_WritePage_0
    307              
    308              /**
    309             * write data
    310             */
    311              if (NoOfBytes > EEPROM_PAGE_SIZE)
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0x1C80             ADDS     R0,R0,#+2        ;; #+257
   \   0000001E   0x4285             CMP      R5,R0
   \   00000020   0xD301             BCC      ??EEPROM_WritePage_2
    312              {
    313                  return ee_too_big;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE029             B        ??EEPROM_WritePage_1
    314              }
    315              
    316              // send the PAGE_PROGRAM command
    317              status |= EEPROM_SendCmd(EEPROM_CMD_PROGRAM_PAGE, EEPROM_CMD_CNT );
   \                     ??EEPROM_WritePage_2: (+1)
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x.... 0x....      BL       EEPROM_SendCmd
   \   0000002E   0x4320             ORRS     R0,R0,R4
   \   00000030   0x0004             MOVS     R4,R0
    318              // send the address
    319              status |= EEPROM_SendAddress(Addr);
   \   00000032   0x0038             MOVS     R0,R7
   \   00000034   0x.... 0x....      BL       EEPROM_SendAddress
   \   00000038   0x4320             ORRS     R0,R0,R4
   \   0000003A   0x0004             MOVS     R4,R0
    320              
    321              /**
    322               * send data
    323               */
    324              gEepromAssertCS_d();
   \   0000003C   0x....             LDR      R0,??DataTable8  ;; 0x400ff008
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x2180             MOVS     R1,#+128
   \   00000042   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   00000044   0x4301             ORRS     R1,R1,R0
   \   00000046   0x....             LDR      R0,??DataTable8  ;; 0x400ff008
   \   00000048   0x6001             STR      R1,[R0, #+0]
    325              
    326              if(spi_master_transfer(mEepromSpiInstance_c, Outbuf, NULL, NoOfBytes) != 0)
   \   0000004A   0x002B             MOVS     R3,R5
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x0031             MOVS     R1,R6
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x.... 0x....      BL       spi_master_transfer
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD001             BEQ      ??EEPROM_WritePage_3
    327              {
    328                  status = ee_error;
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0x0004             MOVS     R4,R0
    329              }
    330              gEepromDeassertCS_d();
   \                     ??EEPROM_WritePage_3: (+1)
   \   0000005E   0x....             LDR      R0,??DataTable6_1  ;; 0x400ff004
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2180             MOVS     R1,#+128
   \   00000064   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   00000066   0x4301             ORRS     R1,R1,R0
   \   00000068   0x....             LDR      R0,??DataTable6_1  ;; 0x400ff004
   \   0000006A   0x6001             STR      R1,[R0, #+0]
    331              
    332              if(status == ee_ok) 
   \   0000006C   0xB2E4             UXTB     R4,R4
   \   0000006E   0x2C00             CMP      R4,#+0
   \   00000070   0xD102             BNE      ??EEPROM_WritePage_4
    333              {
    334                  return status;
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0xB2C0             UXTB     R0,R0
   \   00000076   0xE000             B        ??EEPROM_WritePage_1
    335              }
    336              else
    337              {
    338                  return ee_error;
   \                     ??EEPROM_WritePage_4: (+1)
   \   00000078   0x2004             MOVS     R0,#+4
   \                     ??EEPROM_WritePage_1: (+1)
   \   0000007A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    339              }
    340          }
    341          #endif
    342          
    343          /*****************************************************************************
    344          *  EEPROM_ReadData
    345          *
    346          *  Reads a data buffer from EEPROM, from a given address
    347          *
    348          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    349          ee_err_t EEPROM_ReadData(uint16_t NoOfBytes, uint32_t Addr, uint8_t *inbuf)
    350          {
   \                     EEPROM_ReadData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
    351              ee_err_t status = ee_ok;
   \   00000008   0x2400             MOVS     R4,#+0
    352              
    353              // make sure the write process is ready
    354              while(EEPROM_GetWriteReady() != ee_ok);
   \                     ??EEPROM_ReadData_0: (+1)
   \   0000000A   0x.... 0x....      BL       EEPROM_GetWriteReady
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD1FB             BNE      ??EEPROM_ReadData_0
    355              
    356              // send the PAGE_PROGRAM command
    357              status |= EEPROM_SendCmd(EEPROM_CMD_READ_DATA_BYTES, EEPROM_CMD_CNT );
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x.... 0x....      BL       EEPROM_SendCmd
   \   0000001A   0x4320             ORRS     R0,R0,R4
   \   0000001C   0x0004             MOVS     R4,R0
    358              // send the address
    359              status |= EEPROM_SendAddress(Addr);
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0x.... 0x....      BL       EEPROM_SendAddress
   \   00000024   0x4320             ORRS     R0,R0,R4
   \   00000026   0x0004             MOVS     R4,R0
    360              
    361              if(status != ee_ok)
   \   00000028   0xB2E4             UXTB     R4,R4
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD002             BEQ      ??EEPROM_ReadData_1
    362              {
    363                  status = ee_error;
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x0004             MOVS     R4,R0
   \   00000032   0xE016             B        ??EEPROM_ReadData_2
    364              }
    365              
    366              else
    367              {
    368                  gEepromAssertCS_d();
   \                     ??EEPROM_ReadData_1: (+1)
   \   00000034   0x....             LDR      R0,??DataTable8  ;; 0x400ff008
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x2180             MOVS     R1,#+128
   \   0000003A   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   0000003C   0x4301             ORRS     R1,R1,R0
   \   0000003E   0x....             LDR      R0,??DataTable8  ;; 0x400ff008
   \   00000040   0x6001             STR      R1,[R0, #+0]
    369                  status |= spi_master_transfer(mEepromSpiInstance_c, NULL, inbuf, NoOfBytes);
   \   00000042   0xB2AD             UXTH     R5,R5
   \   00000044   0x002B             MOVS     R3,R5
   \   00000046   0x003A             MOVS     R2,R7
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x.... 0x....      BL       spi_master_transfer
   \   00000050   0x4320             ORRS     R0,R0,R4
   \   00000052   0x0004             MOVS     R4,R0
    370                  gEepromDeassertCS_d();
   \   00000054   0x....             LDR      R0,??DataTable6_1  ;; 0x400ff004
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x2180             MOVS     R1,#+128
   \   0000005A   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   0000005C   0x4301             ORRS     R1,R1,R0
   \   0000005E   0x....             LDR      R0,??DataTable6_1  ;; 0x400ff004
   \   00000060   0x6001             STR      R1,[R0, #+0]
    371              }
    372              
    373              if(status == ee_ok) 
   \                     ??EEPROM_ReadData_2: (+1)
   \   00000062   0xB2E4             UXTB     R4,R4
   \   00000064   0x2C00             CMP      R4,#+0
   \   00000066   0xD102             BNE      ??EEPROM_ReadData_3
    374              {
    375                  return status;
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0xB2C0             UXTB     R0,R0
   \   0000006C   0xE000             B        ??EEPROM_ReadData_4
    376              }
    377              else
    378              {
    379                  return ee_error;
   \                     ??EEPROM_ReadData_3: (+1)
   \   0000006E   0x2004             MOVS     R0,#+4
   \                     ??EEPROM_ReadData_4: (+1)
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    380              }
    381          }
    382          
    383          /*****************************************************************************
    384          *  EEPROM_ReadStatusReq
    385          *
    386          *
    387          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    388          uint8_t EEPROM_isBusy(void)
    389          {
   \                     EEPROM_isBusy: (+1)
   \   00000000   0xB500             PUSH     {LR}
    390              if(EEPROM_IsWriteInProgress() != 0)
   \   00000002   0x....             LDR      R0,??DataTable8_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD501             BPL      ??EEPROM_isBusy_0
    391              {
    392                  return 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B        ??EEPROM_isBusy_1
    393              }
    394              return 0;
   \                     ??EEPROM_isBusy_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??EEPROM_isBusy_1: (+1)
   \   00000010   0xBD00             POP      {PC}             ;; return
    395          }
    396          
    397          /*! *********************************************************************************
    398          * \brief        
    399          *
    400          * \param[in]    
    401          * \param[in]    
    402          ********************************************************************************** */
    403          

   \                                 In section .text, align 2, keep-with-next
    404          ee_err_t EEPROM_ReadStatus(uint8_t* flashStatus)
    405          {
   \                     EEPROM_ReadStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    406              ee_err_t status = ee_ok;
   \   00000004   0x2400             MOVS     R4,#+0
    407              
    408              status |= EEPROM_SendCmd( EEPROM_CMD_READ_STATUS, EEPROM_CMD_CNT );
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x2005             MOVS     R0,#+5
   \   0000000A   0x.... 0x....      BL       EEPROM_SendCmd
   \   0000000E   0x4320             ORRS     R0,R0,R4
   \   00000010   0x0004             MOVS     R4,R0
    409              
    410              if(status == ee_ok) 
   \   00000012   0xB2E4             UXTB     R4,R4
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD111             BNE      ??EEPROM_ReadStatus_0
    411              {
    412                  if(spi_master_transfer(mEepromSpiInstance_c, NULL, &currentStatus, sizeof(currentStatus)) != 0)
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x....             LDR      R2,??DataTable8_1
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       spi_master_transfer
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD002             BEQ      ??EEPROM_ReadStatus_1
    413                  {
    414                      status |= ee_error;
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x2404             MOVS     R4,#+4
   \   0000002C   0x4304             ORRS     R4,R4,R0
    415                  }
    416                  
    417                  gEepromDeassertCS_d();
   \                     ??EEPROM_ReadStatus_1: (+1)
   \   0000002E   0x....             LDR      R0,??DataTable6_1  ;; 0x400ff004
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2180             MOVS     R1,#+128
   \   00000034   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   00000036   0x4301             ORRS     R1,R1,R0
   \   00000038   0x....             LDR      R0,??DataTable6_1  ;; 0x400ff004
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    418              }
    419              
    420              if(status != ee_ok) 
   \                     ??EEPROM_ReadStatus_0: (+1)
   \   0000003C   0xB2E4             UXTB     R4,R4
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD002             BEQ      ??EEPROM_ReadStatus_2
    421              {
    422                 status = ee_error; 
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0x0004             MOVS     R4,R0
   \   00000046   0xE004             B        ??EEPROM_ReadStatus_3
    423              }
    424              else
    425              {
    426                  if ( NULL != flashStatus )
   \                     ??EEPROM_ReadStatus_2: (+1)
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD002             BEQ      ??EEPROM_ReadStatus_3
    427                  {
    428                      *flashStatus = currentStatus;
   \   0000004C   0x....             LDR      R0,??DataTable8_1
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x7028             STRB     R0,[R5, #+0]
    429                  }
    430              }
    431              
    432              return status;
   \                     ??EEPROM_ReadStatus_3: (+1)
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    433          }
    434          
    435          /*! *********************************************************************************
    436          *************************************************************************************
    437          * Private Functions
    438          *************************************************************************************
    439          ********************************************************************************** */
    440          
    441          /*! *********************************************************************************
    442          * \brief        
    443          *
    444          * \param[in]    
    445          * \param[in]    
    446          ********************************************************************************** */
    447          

   \                                 In section .text, align 2, keep-with-next
    448          static ee_err_t EEPROM_SendCmd(const uint8_t cmdToSend, uint8_t  endFlag)
    449          {
   \                     EEPROM_SendCmd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000E             MOVS     R6,R1
    450              ee_err_t status = ee_ok;
   \   00000006   0x2400             MOVS     R4,#+0
    451              uint8_t txSize = 1, cmdBuf[1];
   \   00000008   0x2501             MOVS     R5,#+1
    452              
    453              cmdBuf[0] = cmdToSend;
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x7007             STRB     R7,[R0, #+0]
    454              
    455              gEepromAssertCS_d();
   \   0000000E   0x....             LDR      R0,??DataTable8  ;; 0x400ff008
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x2180             MOVS     R1,#+128
   \   00000014   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   00000016   0x4301             ORRS     R1,R1,R0
   \   00000018   0x....             LDR      R0,??DataTable8  ;; 0x400ff008
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    456              
    457              if(spi_master_transfer(mEepromSpiInstance_c, cmdBuf, NULL, txSize) != 0)
   \   0000001C   0xB2ED             UXTB     R5,R5
   \   0000001E   0x002B             MOVS     R3,R5
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       spi_master_transfer
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD001             BEQ      ??EEPROM_SendCmd_0
    458              {
    459                  status = ee_error;
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x0004             MOVS     R4,R0
    460              }
    461              
    462              if ( EEPROM_CMD_END == endFlag )
   \                     ??EEPROM_SendCmd_0: (+1)
   \   00000032   0xB2F6             UXTB     R6,R6
   \   00000034   0x2E01             CMP      R6,#+1
   \   00000036   0xD106             BNE      ??EEPROM_SendCmd_1
    463              {
    464                  gEepromDeassertCS_d();
   \   00000038   0x....             LDR      R0,??DataTable8_2  ;; 0x400ff004
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x2180             MOVS     R1,#+128
   \   0000003E   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   00000040   0x4301             ORRS     R1,R1,R0
   \   00000042   0x....             LDR      R0,??DataTable8_2  ;; 0x400ff004
   \   00000044   0x6001             STR      R1,[R0, #+0]
    465              }
    466                  
    467              return status;
   \                     ??EEPROM_SendCmd_1: (+1)
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xB2C0             UXTB     R0,R0
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    468          }
    469          
    470          /*! *********************************************************************************
    471          * \brief        
    472          *
    473          * \param[in]    
    474          * \param[in]    
    475          ********************************************************************************** */
    476          

   \                                 In section .text, align 2, keep-with-next
    477          static ee_err_t EEPROM_GetWriteReady()
    478          {
   \                     EEPROM_GetWriteReady: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    479              ee_err_t status = ee_ok;
   \   00000002   0x2400             MOVS     R4,#+0
    480              
    481              /**
    482              * make sure there is no other writing in progress
    483              */
    484              status = EEPROM_ReadStatus( NULL );
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       EEPROM_ReadStatus
   \   0000000A   0x0004             MOVS     R4,R0
    485              
    486              if(status != ee_ok) 
   \   0000000C   0xB2E4             UXTB     R4,R4
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD001             BEQ      ??EEPROM_GetWriteReady_0
    487              {
    488                  return ee_error;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE029             B        ??EEPROM_GetWriteReady_1
    489              }
    490              
    491              if (EEPROM_IsWriteInProgress())
   \                     ??EEPROM_GetWriteReady_0: (+1)
   \   00000016   0x....             LDR      R0,??DataTable8_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x07C0             LSLS     R0,R0,#+31
   \   0000001C   0xD50C             BPL      ??EEPROM_GetWriteReady_2
    492              {
    493                  /**
    494                   * poll untill the writing is enabled
    495                  */
    496                  while (1)
    497                  {
    498                      status = EEPROM_ReadStatus( NULL );
   \                     ??EEPROM_GetWriteReady_3: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       EEPROM_ReadStatus
   \   00000024   0x0004             MOVS     R4,R0
    499                      if (status != ee_ok)
   \   00000026   0xB2E4             UXTB     R4,R4
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD001             BEQ      ??EEPROM_GetWriteReady_4
    500                      {
    501                          return ee_error;
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xE01C             B        ??EEPROM_GetWriteReady_1
    502                      }
    503          
    504                      if (EEPROM_IsWriteNotInProgress())
   \                     ??EEPROM_GetWriteReady_4: (+1)
   \   00000030   0x....             LDR      R0,??DataTable8_1
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x07C0             LSLS     R0,R0,#+31
   \   00000036   0xD4F2             BMI      ??EEPROM_GetWriteReady_3
    505                      {
    506                          break;
    507                      }
    508                  }
    509              }
    510              
    511              /**
    512             * make sure WEL bit is HIGH (writing is enabled)
    513             */
    514              while (1)
    515              {
    516                  status = EEPROM_ReadStatus( NULL );
   \                     ??EEPROM_GetWriteReady_2: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       EEPROM_ReadStatus
   \   0000003E   0x0004             MOVS     R4,R0
    517                  if (status != ee_ok)
   \   00000040   0xB2E4             UXTB     R4,R4
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD001             BEQ      ??EEPROM_GetWriteReady_5
    518                  {
    519                      return ee_error;
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0xE00F             B        ??EEPROM_GetWriteReady_1
    520                  }
    521                  else
    522                  {
    523                      if (EEPROM_IsWriteEnabled())
   \                     ??EEPROM_GetWriteReady_5: (+1)
   \   0000004A   0x....             LDR      R0,??DataTable8_1
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x1040             ASRS     R0,R0,#+1
   \   00000050   0x07C0             LSLS     R0,R0,#+31
   \   00000052   0xD501             BPL      ??EEPROM_GetWriteReady_6
    524                      {
    525                          break;
    526                      }
    527          
    528                      else
    529                      {
    530                          status = EEPROM_SendCmd( EEPROM_CMD_WRITE_ENABLE, EEPROM_CMD_END );
    531                          if (status != ee_ok)
    532                          {
    533                              return ee_error;
    534                          }
    535                      }
    536                  }
    537              }
    538              
    539              return ee_ok;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE008             B        ??EEPROM_GetWriteReady_1
   \                     ??EEPROM_GetWriteReady_6: (+1)
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x2006             MOVS     R0,#+6
   \   0000005C   0x.... 0x....      BL       EEPROM_SendCmd
   \   00000060   0x0004             MOVS     R4,R0
   \   00000062   0xB2E4             UXTB     R4,R4
   \   00000064   0x2C00             CMP      R4,#+0
   \   00000066   0xD0E7             BEQ      ??EEPROM_GetWriteReady_2
   \   00000068   0x2004             MOVS     R0,#+4
   \                     ??EEPROM_GetWriteReady_1: (+1)
   \   0000006A   0xBD10             POP      {R4,PC}          ;; return
    540          }
    541          
    542          /*! *********************************************************************************
    543          * \brief        
    544          *
    545          * \param[in]    
    546          * \param[in]    
    547          ********************************************************************************** */
    548          

   \                                 In section .text, align 2, keep-with-next
    549          static ee_err_t EEPROM_SendAddress(uint32_t eepromAddress)
    550          {
   \                     EEPROM_SendAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    551              ee_err_t status = ee_ok;
   \   00000004   0x2500             MOVS     R5,#+0
    552              uint32_t fmtAddr = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    553              
    554              // if the address is bigger than 24 bytes, exit
    555              if ( eepromAddress > 0x00FFFFFF)
   \   0000000A   0x2080             MOVS     R0,#+128
   \   0000000C   0x0440             LSLS     R0,R0,#+17       ;; #+16777216
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD301             BCC      ??EEPROM_SendAddress_0
    556              {
    557                  return ee_error;
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0xE01C             B        ??EEPROM_SendAddress_1
    558              }
    559          
    560              // arrange bytes
    561              fmtAddr |= ( eepromAddress & 0xFF0000 ) >> 16;
   \                     ??EEPROM_SendAddress_0: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x0C09             LSRS     R1,R1,#+16
   \   0000001C   0xB2C9             UXTB     R1,R1
   \   0000001E   0x4301             ORRS     R1,R1,R0
   \   00000020   0x9100             STR      R1,[SP, #+0]
    562              fmtAddr |= ( eepromAddress & 0x00FF00 );
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x21FF             MOVS     R1,#+255
   \   00000026   0x0209             LSLS     R1,R1,#+8        ;; #+65280
   \   00000028   0x4021             ANDS     R1,R1,R4
   \   0000002A   0x4301             ORRS     R1,R1,R0
   \   0000002C   0x9100             STR      R1,[SP, #+0]
    563              fmtAddr |= ( eepromAddress & 0x0000FF ) << 16;
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0xB2E1             UXTB     R1,R4
   \   00000032   0x0409             LSLS     R1,R1,#+16
   \   00000034   0x4301             ORRS     R1,R1,R0
   \   00000036   0x9100             STR      R1,[SP, #+0]
    564              
    565              if(spi_master_transfer(mEepromSpiInstance_c, (uint8_t*)&fmtAddr, NULL, 3) != 0)
   \   00000038   0x2303             MOVS     R3,#+3
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      BL       spi_master_transfer
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD001             BEQ      ??EEPROM_SendAddress_2
    566              {
    567                  status = ee_error;
   \   00000048   0x2004             MOVS     R0,#+4
   \   0000004A   0x0005             MOVS     R5,R0
    568              }
    569            
    570            
    571              return status;
   \                     ??EEPROM_SendAddress_2: (+1)
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0xB2C0             UXTB     R0,R0
   \                     ??EEPROM_SendAddress_1: (+1)
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    572          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     mEepromEraseBitmap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x400FF004         DC32     0x400ff004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x400FF008         DC32     0x400ff008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     currentStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x400FF004         DC32     0x400ff004
    573          
    574          
    575          
    576          #endif /* gEepromDevice_M25P80_c */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   EEPROM_ChipErase
         8   -> EEPROM_GetWriteReady
         8   -> EEPROM_SendCmd
      16   EEPROM_EraseBlock
        16   -> EEPROM_GetWriteReady
        16   -> EEPROM_SendAddress
        16   -> EEPROM_SendCmd
       8   EEPROM_GetWriteReady
         8   -> EEPROM_ReadStatus
         8   -> EEPROM_SendCmd
      16   EEPROM_Init
        16   -> spi_master_configure_bus
        16   -> spi_master_init
      40   EEPROM_PrepareForWrite
        40   -> EEPROM_EraseBlock
        40   -> EEPROM_isBusy
        40 __aeabi_uidivmod
      24   EEPROM_ReadData
        24   -> EEPROM_GetWriteReady
        24   -> EEPROM_SendAddress
        24   -> EEPROM_SendCmd
        24   -> spi_master_transfer
      16   EEPROM_ReadStatus
        16   -> EEPROM_SendCmd
        16   -> spi_master_transfer
      16   EEPROM_SendAddress
        16   -> spi_master_transfer
      24   EEPROM_SendCmd
        24   -> spi_master_transfer
      24   EEPROM_WriteData
        24   -> EEPROM_GetWriteReady
        24   -> EEPROM_PrepareForWrite
        24   -> EEPROM_WritePage
      24   EEPROM_WritePage
        24   -> EEPROM_GetWriteReady
        24   -> EEPROM_SendAddress
        24   -> EEPROM_SendCmd
        24   -> spi_master_transfer
       4   EEPROM_isBusy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
      20  EEPROM_ChipErase
      78  EEPROM_EraseBlock
     108  EEPROM_GetWriteReady
      76  EEPROM_Init
     152  EEPROM_PrepareForWrite
     114  EEPROM_ReadData
      88  EEPROM_ReadStatus
      82  EEPROM_SendAddress
      76  EEPROM_SendCmd
     122  EEPROM_WriteData
     124  EEPROM_WritePage
      18  EEPROM_isBusy
       1  currentStatus
      64  mEepromEraseBitmap

 
    65 bytes in section .bss
 1 078 bytes in section .text
 
 1 078 bytes of CODE memory
    65 bytes of DATA memory

Errors: none
Warnings: none
